package parser;   
import java_cup.runtime.*;
import syntaxtree.*;
import java.util.*;


parser code {:

:};

/* Terminals */
/* Note, those might not be the terminals for this semester     */
/* Not all tokens are covered here, some may not be useful,     */
/* for instance, we won't have a "class" keyword,               */
/* but a "struct". Hence a corresponding token should better    */
/* be called STRUCT or similar, for clarity.                    */
terminal                        PROGRAM, STRUCT;
terminal                        BEGIN, END;
terminal                        LPAR, RPAR;
terminal                        SEMI, RETURN;
terminal                        PROCEDURE;
terminal String                 ID;
terminal String                 STRING_LITERAL;
terminal                        VAR;
terminal                        COLON;
terminal                        FLOAT;
terminal                        INT;
terminal                        STRING;
terminal                        BOOL;
terminal                        REF;
terminal                        ASSIGN;
terminal                        IN;
terminal                        LBRACKET;
terminal                        RBRACKET;
terminal                        NOT;
terminal                        NEW;


// Non terminals 
non terminal Program            program;
non terminal List<Decl>         decl_list;
non terminal Decl               decl;
non terminal VarDecl            var_decl;
non terminal String             type; 
non terminal ProcDecl           proc_decl;
non terminal ParamfieldDecl     paramfield_decl;
non terminal List<Decl>         proc_decl_list;
non terminal RecDecl            rec_decl;
non terminal List<RecDecl>      rec_decl_list;
non terminal List<Stmt>         stmt_list;
non terminal Exp                exp;


/* The grammar */
program         ::= PROGRAM ID:name BEGIN decl_list:dl END
                        {: RESULT = new Program(name, dl); :} 
                  ;

decl_list       ::= decl:d SEMI {: List<Decl> l = new LinkedList<Decl>();
                                      l.add(d);
                                      RESULT = l; :} 
                        |   decl_list:dl decl:d SEMI  {: dl.add(d); RESULT = dl; :};

decl            ::= VAR_DECL:vd  {: RESULT = new Decl(vd); :} 
                  | PROC_DECL:pd {: RESULT = new Decl(pd); :} 
                  | REC_DECL:rd  {: RESULT = new Decl(rd); :};
                                  
class_decl      ::= CLASS ID:name BEGIN END
                        {: RESULT = new ClassDecl(name); :}
                  ;

var_decl        ::= VAR ID:name COLON type:t [ASSIGN exp:e]
                        {: RESULT = new VarDecl(name, t, e); :}
                  | VAR ID:name ASSIGN exp:e
                        {: RESULT = new VarDecl(name, e); :}
                  ;

type            ::= FLOAT   {: RESULT = "float"; :}
                  | INT     {: RESULT = "int"; :}
                  | STRING  {: RESULT = "string"; :}
                  | BOOL    {: RESULT = "bool"; :}
                  | ID:name {: RESULT =  name; :}
                  | REF LPAR type:t RPAR {: RESULT = t; :}

proc_decl       ::= PROCEDURE ID:name 
                    LPAR [proc_decl_list:pfd] RPAR 
                    [SEMI type:t] 
                    BEGIN [decl_list:dl IN] stmt_list:sl END
                    {: RESULT = new ProcDecl(name, pfd, t, dl, sl) :};


proc_decl_list  ::= paramfield_decl:pfd COMMA {: List<ParamfieldDecl> l = new LinkedList<ParamfieldDecl>();
                                      l.add(pfd);
                                      RESULT = l; :}                         
                  | proc_decl_list:pdl paramfield_decl:pfd COMMA {: pdl.add(pfd); RESULT = pdl; :};


paramfield_decl ::= ID:name COLON type:t {: RESULT = new ParamfieldDecl(name, t) :};


rec_decl ::= STRUCT ID:name LBRACKET [rec_decl_list:rdl] RBRACKET {: RESULT = new RecDecl(name, rdl); :} 

rec_decl_list  ::= paramfield_decl:pfd SEMI {: List<ParamfieldDecl> l = new LinkedList<ParamfieldDecl>();
                                      l.add(pfd);
                                      RESULT = l; :}                         
                  | rec_decl_list:rdl paramfield_decl:pfd SEMI {: rdl.add(pfd); RESULT = rdl; :};


stmt_list ::= [ stmt:s SEMI {: List<Stmt> l = new LinkedList<Stmt>();
                                      l.add(s);
                                      RESULT = l; :}                         
                  | stmt_list:sl stmt:s SEMI {: sl.add(s); RESULT = sl; :};
              ]

exp ::= exp:e1 log_op:o exp:e2     {: RESULT = new Exp(e1, o, e2); :} 
      | NOT exp:e                  {: RESULT = new Exp(e); :} 
      | exp:e1 rel_op:o exp:exp2   {: RESULT = new Exp(e1, o, e2); :} 
      | exp:e1 arith_op:o exp:exp2 {: RESULT = new Exp(e1, o, e2); :} 
      | literal:e                  {: RESULT = new Exp(e); :} 
      | call_stmt:e                {: RESULT = new Exp(e); :} 
      | NEW ID:name                {: RESULT = new Exp(name); :} 
      | var:e                      {: RESULT = new Exp(e); :} 
      | ref_var:e                  {: RESULT = new Exp(e); :} 
      | deref_var:e                {: RESULT = new Exp(e); :} 
      | LPAR exp:e RPAR            {: RESULT = new Exp(e); :} 
      