% Created 2019-02-22 Fri 11:11
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Martin Steffen}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={Martin Steffen},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 24.3.1 (Org mode 9.2.1)}, 
 pdflang={English}}
\begin{document}

\tableofcontents


\section{Introduction}
\label{sec:org5e4b714}

This report presents the local variant of \emph{bytecode}, \emph{bytecode
interpreter}, and \emph{bytecode construction library} written for the compiler
construction course INF5110 and the University of Oslo. The bytpecode
library and intepreter were developed to be used in the \emph{code generation}
and \emph{runtime} part of the obligatory exercises in the course. The objective
of this exercise is to write a compiler for a simple example language.


Bytecodes in general similar to machine code, but instead of being run
directly on a machine, they are usually interpreted by a bytecode
interpreter. They may also be translated into machine code before being
run. A bytpecode instruction library is a library to simplify the task of
generating bytecode for a bytecode interpreter. Bytecode is name exactly
that because each instruction is the size of a byte.

Our bytecode is quite similar to Java bytecode and our bytecode library is
based on the \href{http://commons.apache.org/proper/commons-bcel/}{Byte Code Engineering Library}.\footnote{\texttt{http://commons.apache.org/proper/commons-bcel/}, formerly as
part of the Jakarta project.} We choose to write a
simpler, stripped-down version that, for instance, does not support
classes, virtual procedures, and all the other things that Java's bytecode
has. We did that so that it would be simpler to work with, and there would
be less code. For instance, one does not need to create classes like, since
our language does not have them, just for ``some reasons
unexplained''. Still, we encorange students to look at BCEL, as it's a nice
tool and very well designed.




The bytecode library and the interpreter are, not surprisingly, written in
Java. All the code is written in source form and consists of the following
packages.

\begin{itemize}
\item \texttt{bytecode.*}:    classes to create bytecode
\item \texttt{bytecode.instructions.*}  instruction classes, supporting the above
\item \texttt{bytecode.type.*}  type classes, supporting the above
\item \texttt{runtime.*} : classes of the runtime system
\end{itemize}

\subsection{The interpreter}
\label{sec:org7d9d84c}

The interpreter is \emph{stack based} and it interprets about 40 different
instructions of our bytecode.  The interpreter ``automatically'' handles
allocation of struct types, method calls and access of variables in a
struct when instructed to, by the bytecode instructions. In the first
version it does \emph{not} have a garbage collector and allocates memory
sequentially as long as there is memory left.

\index{instruction}
\index{operation}
The operators or instructions are so called \emph{stack operations}. It means that
whe the intpreter executes an instruction, it pops off a number of operands
from the stack (0 or more), performs the task specified by the instruction,
and leaves a number of result values on the stack, typically just one such
value.

The interpreter is not written for efficiency, by rather for readability
and ease of creating runnable bytecode. For instance, the types are kept on
the stack together with the calculated values and the interpreter decides
what kind of operation to perform based on the types as well as the current
instruction. For example, an \texttt{ADD} instruction, representing addition, will
be performed differently if there are two integers on the stack, two
floats, or one of each. That's different from Java bytecode, which has an
\texttt{ADDINT} and an \texttt{ADDFLOAT} instruction and wher type casting has to be done
explicitly in the bytecode (for example with the \texttt{i2f} instruction, which
does the corresponding conversion).

\subsection{Interpreting bytecode}
\label{sec:orgb91ad79}


As mentioned, the interpreter is stack based. The parameters from right to
left in an operation (including user defined functions) must be placed on
the stack with the leftmost on the bottom and the rightmost on the top of
the stack before the instruction itself is interpreted. For example, the
\texttt{SUB} (subtraction) instruction requires that the two operands the \texttt{SUB}
instruction will be applied to are on the stack and in the right order
beforehand. The number to subtract must be on the top and the number to
subtract from below it. We may denote the elements on the stack before an
instruction is interpreted with \(s_n\), where \(n\) is the index from the top,
with the top as \(n = 0\). Then, the result of the \texttt{SUB} instruction is that
the two values on the top of the stack is removed and replaced by \(s_1 -
s_0\).

\subsection{The library}
\label{sec:org5157000}

The library has a class \href{../../../material/oblig2-patch/src/bytecode/CodeFile.java}{CodeFile} that is the base class for creating a
program with ``runnable'' sequences of instructions, i.e. a (binary or
\texttt{.bin}) file, executable by the virtual machine or more specifically by the
virtual machine interpreter.


To create such a bytecode file, one must create an object of the class
\texttt{CodeFile} and add procedures, structs and global variables using the
procedures of the \texttt{CodeFile} object. Objects that represent local variables
and instructions are created using the library and added to the procedure
objects, which are of class \texttt{CodeProcedure}. When the program is complete,
that is, when all the elements of the program has been added to the
\texttt{CodeFile} object and its \texttt{CodeProcedure} objects, the actual bytecode can
be extracted by the procedure \texttt{getBytecode()} of a \texttt{CodeFile} object.  The
array of bytes that is then created, is usually written to a file, which
can then be read by the virtual machine and run by its interpreter.



A typical use of the \texttt{Codefile} class will be something like this:



\lstset{language=java,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
CodeFile codeFile = new CodeFile();
String filename = "example.bin";

// Building the bytecode with instructions 
// like the following:
codeFile.addProcedure("Main");
CodeProcedure main = 
   new CodeProcedure("Main",
		      VoidType.TYPE,
		      codeFile);
main.addInstruction (new RETURN());
codeFile.updateProcedure(main);

// ... and more ....

byte [] bytecode = codeFile.getBytecode();  // bytecode = array of bytes.
DataOutputStream stream = 
   new DataOutputStream(new FileOuputStream(filename));
stream.write(bytecode);
stream.close();
\end{lstlisting}

In that example, first an object of the class \texttt{CodeFile} is created. Then,
the procedure \texttt{"main"} is added to it. More procedures, structs, global
variables, and constants by be added to it. Then one can get the bytecode,
which is an array of bytes, and write it to a file, as shown in the code
snippet.

The generated bytecode file can then be inspected, for instance with an
editor for binary files like the Eclipse Hex Editor Plugin (\href{http://ehep.sourceforge.net/}{EHEP}).\footnote{For Ehep, see \texttt{http://ehep.sourceforge.net/} or
\texttt{https://marketplace.eclipse.org/content/ehep-eclipse-hex-editor-plugin}.}

\subsection{Using the virtual machine}
\label{sec:org9e7a559}

There are two ways to runa program from a bytecode file. Both are provided
by the class \href{../../../material/oblig2-patch/src/runtime/VirtualMachine.java}{VirtualMachine}.


One is to use the \emph{command line}, writing


\begin{verbatim}
java runtime.VirtualMachine <FILENAME>
\end{verbatim}

The other is, inside a progra, to instantiate the class \texttt{VirtualMachine}
and call its \texttt{run} method.

\begin{verbatim}
VirtualMachine vm = new VirtualMachine("<FILENAME>");
vm.run();
\end{verbatim}

This class \texttt{VirtualMachine} can also list the content of the bytecode fule
in textual form. Also this can be done in two ways: via the command option
\texttt{-l} or, from inside a program, using the \texttt{list} method:

\begin{verbatim}
java runtime.VirtualMachine -l <FILENAME>
\end{verbatim}

resp.

\begin{verbatim}
VirtualMachine vm = new VirtualMachine("<FILENAME>");
vm.run();
\end{verbatim}

As an example, assume a program like this

\lstset{language=java,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
// File: ./Simple.d
struct Complex {
  var float Real;
  var float Imag;
}

var Complex dummy;
func Main () { }
\end{lstlisting}

Listing the generated bytecode with the \texttt{-l} option would then look as
follows.

\begin{verbatim}
Loading from file: ./Simple.bin
Variables:
0: var Complex dummy
Procedures:
0: Main()
   0: return
Structs:
0: Complex
     0: float
     1: float
Constants:
STARTWITH: Main
\end{verbatim}



\subsection{Source code overview}
\label{sec:org852c119}

The most important classes and packages of the bytecode library are
\texttt{[[srcbytecode:CodeFile.java][CodeFile]]} \texttt{x}
\end{document}