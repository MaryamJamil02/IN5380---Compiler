% Created 2019-02-27 Wed 10:20
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\input{preamble}
\input{macros}
\author{Fredrik Sørensen, Stein Krogdahl, Birger Møller-Pedersen}
\date{Spring semester 2019}
\title{Bytecode interpreter}
\hypersetup{
 pdfauthor={Fredrik Sørensen, Stein Krogdahl, Birger Møller-Pedersen},
 pdftitle={Bytecode interpreter},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 24.3.1 (Org mode 9.2)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Introduction}
\label{sec:org9eb8a76}

This report presents the local variant of \emph{bytecode}, \emph{bytecode
interpreter}, and \emph{bytecode construction library} written for the compiler
construction course INF5110 and the University of Oslo. The bytpecode
library and intepreter were developed to be used in the \emph{code generation}
and \emph{runtime} part of the obligatory exercises in the course. The objective
of this exercise is to write a compiler for a simple example language.


Bytecodes in general similar to machine code, but instead of being run
directly on a machine, they are usually interpreted by a bytecode
interpreter. They may also be translated into machine code before being
run. A bytpecode instruction library is a library to simplify the task of
generating bytecode for a bytecode interpreter. Bytecode is name exactly
that because each instruction is the size of a byte.

Our bytecode is quite similar to Java bytecode and our bytecode library is
based on the \href{http://commons.apache.org/proper/commons-bcel/}{Byte Code Engineering Library}.\footnote{\texttt{http://commons.apache.org/proper/commons-bcel/}, formerly as
part of the Jakarta project.} We choose to write a
simpler, stripped-down version that, for instance, does not support
classes, virtual procedures, and all the other things that Java's bytecode
has. We did that so that it would be simpler to work with, and there would
be less code. For instance, one does not need to create classes like, since
our language does not have them, just for ``some reasons
unexplained''. Still, we encorange students to look at BCEL, as it's a nice
tool and very well designed.




The bytecode library and the interpreter are, not surprisingly, written in
Java. All the code is written in source form and consists of the following
packages.

\begin{itemize}
\item \texttt{bytecode.*}:    classes to create bytecode
\item \texttt{bytecode.instructions.*}  instruction classes, supporting the above
\item \texttt{bytecode.type.*}  type classes, supporting the above
\item \texttt{runtime.*} : classes of the runtime system
\end{itemize}

\subsection{The interpreter}
\label{sec:org5c46982}

The interpreter is \emph{stack based} and it interprets about 40 different
instructions of our bytecode.  The interpreter ``automatically'' handles
allocation of struct types, method calls and access of variables in a
struct when instructed to, by the bytecode instructions. In the first
version it does \emph{not} have a garbage collector and allocates memory
sequentially as long as there is memory left.

\index{instruction}
\index{operation}
The operators or instructions are so called \emph{stack operations}. It means that
whe the intpreter executes an instruction, it pops off a number of operands
from the stack (0 or more), performs the task specified by the instruction,
and leaves a number of result values on the stack, typically just one such
value.

The interpreter is not written for efficiency, by rather for readability
and ease of creating runnable bytecode. For instance, the types are kept on
the stack together with the calculated values and the interpreter decides
what kind of operation to perform based on the types as well as the current
instruction. For example, an \texttt{ADD} instruction, representing addition, will
be performed differently if there are two integers on the stack, two
floats, or one of each. That's different from Java bytecode, which has an
\texttt{ADDINT} and an \texttt{ADDFLOAT} instruction and wher type casting has to be done
explicitly in the bytecode (for example with the \texttt{i2f} instruction, which
does the corresponding conversion).

\subsection{Interpreting bytecode}
\label{sec:org5332c98}


As mentioned, the interpreter is stack based. The parameters from right to
left in an operation (including user defined functions) must be placed on
the stack with the leftmost on the bottom and the rightmost on the top of
the stack before the instruction itself is interpreted. For example, the
\texttt{SUB} (subtraction) instruction requires that the two operands the \texttt{SUB}
instruction will be applied to are on the stack and in the right order
beforehand. The number to subtract must be on the top and the number to
subtract from below it. We may denote the elements on the stack before an
instruction is interpreted with \(s_n\), where \(n\) is the index from the top,
with the top as \(n = 0\). Then, the result of the \texttt{SUB} instruction is that
the two values on the top of the stack is removed and replaced by \(s_1 -
s_0\).

\subsection{The library}
\label{sec:org07be295}

The library has a class \href{../../../material/oblig2-patch/src/bytecode/CodeFile.java}{CodeFile} that is the base class for creating a
program with ``runnable'' sequences of instructions, i.e. a (binary or
\texttt{.bin}) file, executable by the virtual machine or more specifically by the
virtual machine interpreter.


To create such a bytecode file, one must create an object of the class
\texttt{CodeFile} and add procedures, structs and global variables using the
procedures of the \texttt{CodeFile} object. Objects that represent local variables
and instructions are created using the library and added to the procedure
objects, which are of class \texttt{CodeProcedure}. When the program is complete,
that is, when all the elements of the program has been added to the
\texttt{CodeFile} object and its \texttt{CodeProcedure} objects, the actual bytecode can
be extracted by the procedure \texttt{getBytecode()} of a \texttt{CodeFile} object.  The
array of bytes that is then created, is usually written to a file, which
can then be read by the virtual machine and run by its interpreter.



A typical use of the \texttt{Codefile} class will be something like this:



\lstset{language=java,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
CodeFile codeFile = new CodeFile();
String filename = "example.bin";

// Building the bytecode with instructions 
// like the following:
codeFile.addProcedure("Main");
CodeProcedure main = 
   new CodeProcedure("Main",
		      VoidType.TYPE,
		      codeFile);
main.addInstruction (new RETURN());
codeFile.updateProcedure(main);

// ... and more ....

byte [] bytecode = codeFile.getBytecode();  // bytecode = array of bytes.
DataOutputStream stream = 
   new DataOutputStream(new FileOuputStream(filename));
stream.write(bytecode);
stream.close();
\end{lstlisting}

In that example, first an object of the class \texttt{CodeFile} is created. Then,
the procedure \texttt{"main"} is added to it. More procedures, structs, global
variables, and constants by be added to it. Then one can get the bytecode,
which is an array of bytes, and write it to a file, as shown in the code
snippet.

The generated bytecode file can then be inspected, for instance with an
editor for binary files like the Eclipse Hex Editor Plugin (\href{http://ehep.sourceforge.net/}{EHEP}).\footnote{For Ehep, see \texttt{http://ehep.sourceforge.net/} or
\texttt{https://marketplace.eclipse.org/content/ehep-eclipse-hex-editor-plugin}.}

\subsection{Using the virtual machine}
\label{sec:org916f425}

There are two ways to runa program from a bytecode file. Both are provided
by the class \href{../../../material/oblig2-patch/src/runtime/VirtualMachine.java}{VirtualMachine}.


One is to use the \emph{command line}, writing


\begin{verbatim}
java runtime.VirtualMachine <FILENAME>
\end{verbatim}

The other is, inside a progra, to instantiate the class \texttt{VirtualMachine}
and call its \texttt{run} method.

\begin{verbatim}
VirtualMachine vm = new VirtualMachine("<FILENAME>");
vm.run();
\end{verbatim}

This class \texttt{VirtualMachine} can also list the content of the bytecode fule
in textual form. Also this can be done in two ways: via the command option
\texttt{-l} or, from inside a program, using the \texttt{list} method:

\begin{verbatim}
java runtime.VirtualMachine -l <FILENAME>
\end{verbatim}

resp.

\begin{verbatim}
VirtualMachine vm = new VirtualMachine("<FILENAME>");
vm.run();
\end{verbatim}

As an example, assume a program like this

\lstset{language=java,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
// File: ./Simple.d
struct Complex {
  var float Real;
  var float Imag;
}

var Complex dummy;
func Main () { }
\end{lstlisting}

Listing the generated bytecode with the \texttt{-l} option would then look as
follows.

\begin{verbatim}
Loading from file: ./Simple.bin
Variables:
0: var Complex dummy
Procedures:
0: Main()
   0: return
Structs:
0: Complex
     0: float
     1: float
Constants:
STARTWITH: Main
\end{verbatim}



\subsection{Source code overview}
\label{sec:org06cf4b0}

The \href{../../../material/oblig2-patch/src/bytecode/}{bytecode library} contains classes and sub-packages. The most important
classes are the follwoing

\begin{itemize}
\item \href{../../../material/oblig2-patch/src/bytecode/CodeFile.java}{\texttt{CodeFile}},
\item \href{../../../material/oblig2-patch/src/bytecode/CodeProcedure.java}{\texttt{CodeProcedure}}, and
\item \href{../../../material/oblig2-patch/src/bytecode/CodeStruct.java}{\texttt{CodeStruct}}.
\end{itemize}

The first one is the the main class for creating byte code the other two
for creating a procedure resp. a struct in the byte code. As for the
sub-packages (i.e., subdirectories), there are 2

\begin{itemize}
\item \href{../../../material/oblig2-patch/src/bytecode/./instructions/}{\texttt{instructions}} and
\item \href{../../../material/oblig2-patch/src/bytecode/type/}{\texttt{type}}
\end{itemize}

corresponding to the packages \texttt{bytecode.instructions.*} and
\texttt{bytecode.type.*}.  The instructions in the first package are represented
as concrete subclasses of the abstract \href{../../../material/oblig2-patch/src/bytecode/./instructions/Instruction.java}{\texttt{Instruction}} class.  Similarly for
the types (as subclasses of the abstract \href{../../../material/oblig2-patch/src/bytecode/./type/CodeType.java}{\texttt{CodeType}} class. That package
contains all the types used in the byte code.

Although usually not used by a programmer, it might be nice to know the
main classes of the virtual machine resp. the run-time system, as well. See
the package resp. directory \href{../../../material/oblig2-patch/src/runtime/}{\texttt{runtime}} The main classes are the following

\begin{itemize}
\item \href{../../../material/oblig2-patch/src/runtime/VirtualMachine.java}{\texttt{VirtualMachine}}
\item \href{../../../material/oblig2-patch/src/runtime/Loader.java}{\texttt{Loader}}
\item \href{../../../material/oblig2-patch/src/runtime/Interpreter.java}{\texttt{Interpreter}}
\item \href{../../../material/oblig2-patch/src/runtime/Stack.java}{\texttt{Stack}}
\item \href{../../../material/oblig2-patch/src/runtime/Heap.java}{\texttt{Heap}}
\item \href{../../../material/oblig2-patch/src/runtime/ActivationBlock.java}{\texttt{ActivationBlock}}
\end{itemize}

The virtual machine class is the starting point for running a program, the
loader class loads a a program from a file. The actual interpretation of
the byte code is provided by the interpreter class. The classes \texttt{Heap} and
\texttt{Stack} are responsible for management of the corresponding memory. Note
that there is a single stack for each program (as the programs are
single-threaded). The heap contains structs, and they allocation and access
is maintained by the mentioned class. The class for activation blocks
handles and stores the program counter, local variables etc. and also
handles the call and return of a procedure in conjuction with the
interpreter.

\section{Building a complete program}
\label{sec:org2a461d5}

We have shown the basics of how a bytecode program (binary file) is built
using the bytecode library. In this section we will show some of the
details by covering each of the classes in the library. Details about all
the instructions will come in Section \ref{orge4c0527}.

The main parts for creating a new program are: create an object of the
class \texttt{CodeFile}. Afterwards add the procedures, i.e., objects of class
\texttt{CodeProcedure}, structs, i.e., objects of class \texttt{CodeStruct}, and so
on. Finally, when calling the \texttt{getBytecode()} procedure, the bytecode
library will generae the actual bytes from the object hat have been created
and from the ``properties'' given to those objects.

Note that there a \emph{four} steps to create a procedure (or a struct, or
global variable).

\begin{enumerate}
\item \emph{add} the definition to the \texttt{CodeFile} object via \texttt{addProcedure}.
\item \emph{create} the \texttt{CodeProcedure} object via \texttt{new CodeProcedure}.
\item \emph{add} ``properties'', such as the instructions, to the \texttt{CodeProcedure}
object.
\item \emph{update} the \texttt{CodeProcedure} object in the \texttt{CodeFile} via
\texttt{updateProcedure}
\end{enumerate}


These four standard steps are illustrated in slightly more detail in the
following example.k

\subsection{A small example}
\label{sec:org9d0a306}

The example code creates a program and first adds the name of a library
procedure to be used.  It then adds a procedure \texttt{Main}, a global variable
\texttt{myGlobalVar}, a procedure \texttt{test} and a struct \texttt{Complex} (I). The main
procedure has the void return type, no parameters, no local variables and
the body consists of a single instruction, namely \texttt{return} (II). The global
variable is typed with the struct type \texttt{Complex} (III). The procedure
\texttt{test} has 2 parameters (of type float and a reference type to
\texttt{Complex}). The procedure loads the first parameter onto the stack and then
calls the (library) procedure \texttt{print\_float} to print its value (IV). The
struct \texttt{Complex} is created and the two fields, both of floating point
type, are added to it (V). The procedure \texttt{print\_float} used in the program
is a library procedure. Nonetheless, it needs to be added, but without
instructions (VI). See Section \ref{org679199e} Finally, the mandatory main
method is set, before the bytecode can be extracted to a file (VII),



\lstset{language=java,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
// Make code:
CodeFile codeFile = new CodeFile();
codeFile.addProcedure("printFloat")

//-------  (I) ---------------------
codeFile.addProcedure("Main");
codeFile.addVariable("myGlobalVar");
codeFile.addProcedure("test");
codeFile.addStruct("Complex");
//-------- (II) --------------
CodeProcedure main = 
    new CodeProcedure("Main", 
		      VoidType.TYPE, 	     
		      codeFile);
main.addInstruction(new RETURN());
codeFile.updateProcedure(main);

//--------- (III) -------------
codeFile.updateVaraiable("myGlobalVar",
			 new RefType(codeFile.structNumber("Complex")));
//---------- (IV) -------------
CodeProcedure test = new CodeProcedure("test",
				       VoidType.TYPE,
				       codefile);
test.addParameter("firstPar", FloatType.TYPE);
test.addParameter("secondPar", new RefType(test.structNumber("Complex")));
test.addInstruction(new LOADLOCAL(test.variableNumber("firstPar")));
test.addInstruction(new CALL(test.procedureNumber("print_float")));
test.addInstruction(new RETURN());
codeFile.updateProcedure(test);

//---------- (V) ----------------

CodeStruct complex =  new Codestruct("Complex");
complex.addVariable("Real", FloatType.TYPE);
complex.addVariable("Imag", FloatType.TYPE);
codeFile.updateStruct(complex);

//----------- (VI) --------------
CodeProcedure printFloat = new CodeProcedure("print_float",
					     VoidType.TYPE, 
					     codeFile);
test.addParameter("f", FloatType.TYPE);
codeFile.updateProcedure(printFloat);

//----------- (VII) --------------
codeFile.setMain("Main");
byte[] bytecode = codeFile.getBytecode();
//.............. write the bytes to a file
\end{lstlisting}


\subsubsection{Class \texttt{CodeFile}}
\label{sec:orgca50cae}


\index{error: classes are not created}
This is the class type cbyecode is created from and all elements must be
added to the corresponding object. It also proveds the servive of returning
indices to the given elements, as we will see later. Those indices are
needed when instruction classes are created. They reference the elements
within the program. Adding something to a \texttt{CodeFile} object is done in
\emph{two} stages; first, the element is added using something like the
\texttt{addProcedure} procedure, supplying only the name. Then later, the
\texttt{updateProcedure} must be called with a reference to the actual procedure
object. After a procedure has been added (but before it has been updated)
its index can be found and used, for example to crete a call to it, as we
will see.


An object of the \texttt{CodeFile} class is typically seen by all the nodes in the
abstract syntax tree, by for example passign around a reference to it. An
element in the syntax tree is typically responsible for adding itself to
the compiled result by using the procedures of the \texttt{CodeFile} or
\texttt{CodeProcedure} classes.

A \emph{global variable} is added by using the procedure \texttt{void
addVariable(String name)}. After a global variable has been added, its
index (\texttt{id}) in the program may be found using its name, calling the
procedure \texttt{int globalVariableNumber(String name)} The type of the variable
\emph{must} be supplied before the bytecode is generated. It is done by calling
\texttt{void uodateVariable(String name, CodeType type)}. All global variables
must have unique names.


A \emph{procedure} is added by using the procedure \texttt{void addProcedure(String
name)} After a procedure has been added, its index (\texttt{id}) in the program
may be found using its name, calling the procedure \texttt{int
procedureNumber(String name)}. The details of the procedure must be
supplied before the bytecode is generated. It is done by \texttt{public void
updateProcedure(CodeProcedure codeProcedure)}. 


For a struct, there as similar procedures \texttt{public void \textasciitilde{}addStruct(String
name)}, \texttt{int structNumber(String name)}, and \texttt{void updateStruct (CodeStruct
codeStruct)}.  In addition, getting the index of a field in a struct is
done by calling \texttt{int fieldNumber(String structName, String varName)} using
the name of the struct and the name of the field.

A \texttt{string constant} is added by using the procedure \texttt{int
addStringConstant(String value)}. Note that this procdure returns the index
(\texttt{id}) of the constant \emph{directly} and there is no prcedire to fetch the
index of a constant later.  The index is used fro string literals by the
compiler.
\index{string literal}

After all the elements are added, it is important to let the interpreter
know which procedure to start with. This is done by using the the name of
the procedure (typically \texttt{"main"}) and calling \texttt{void SetMain(String name)}.


\subsubsection{Class \texttt{CodeProcedure}}
\label{sec:org3c1d384}

A procedure in the program is made by first adding its name tothe
\texttt{CodeFile} object, then creating an object of this class, then adding the
parameters, local variables, and instructions to the object, and finally by
updating the \texttt{CodeFile} object with the \texttt{CodeProcedure} object.

\index{procedure object}
A \emph{procedure object} is creatd by using the cosntructor
\texttt{CodeProcedure(String name, CodeType returnType, CodeFile codeFile)}. This
takes the unique name of the procedure, the return type (see \texttt{CodeType}
below) and the code file that it will be added to. The reason that the code
file is included is that it is needed by the procedure object to provide
some of the code file services through delegation.

\index{parameter}
\index{local variable}

A \emph{parameter} or \emph{local variable} is added by using the procedures \texttt{void
addParameter(String name, CodeType type)} or \texttt{void addLocalVariable(String
name, CodeType type)}.

\index{instruction}

An \emph{instruction} is added to the procedure object by using \texttt{int
addInstruction(Instruction instruction)}. The return value of this is the
index of the instruction in the procedure's list of instructions. Sometimes
one wants to \emph{replace} and earlier instruction. This is done by using \textasciitilde{}void
replaceInstruction(int place, Instruction instruction). For instance, one
may insert temporarily a \texttt{NOP} instruction to be replaced later by a
\texttt{MP}. Read more in Section XXX on jumps. A procedure must have at least one
instruction and also, that instruction has to be a final \texttt{RETURN}
instruction.

\index{index}
The \emph{index} of a variable or parameter can be found by using \texttt{int
variableNumber(String name)}. Note that local variables mus have unique
names in any block, and that the parameters are included in this. Tje
parameters are given the first indices (\texttt{id\textasciitilde{}s) from left to right, starting
from \textasciitilde{}0}. Then the variables are given the subsequent indices in the order
of declarations.



A \texttt{CodeProcedure} object can find the indices of elements using its
\texttt{CodeFile} object, so it also has the procedures \texttt{globalVariableNumber},
\texttt{procedureNumber}, \texttt{structNumber}, and \texttt{fieldNumber}. It also has and
delegates the \texttt{addStringConstant} procedure.


\subsubsection{Class \texttt{CodeStruct}}
\label{sec:org28c17cd}

\index{struct}
A \emph{struct} is created with the constructor \texttt{CodeStruct(String name)}
providing the name of the struct. A field is added to the struct by using
\texttt{void addVaraible(String name, CodeType type)}. To retrieve the index of a
field added to the struct, one may use \texttt{int fieldNumber(String name)}. See
also the \texttt{fieldNumber} procedure of \texttt{CodeFile}.

\subsubsection{Class \texttt{CodeType}}
\label{sec:org9b26358}
\index{type}

This is an abstract class and it has as concrete subclasses the different
classes of types: \texttt{VoidType}, \texttt{BoolType}, \texttt{IntType}, \texttt{FloatType},
\texttt{StringType} and \texttt{RefType}. The void type is used for procedures that don't
return a value and the reference type is for references to structs (i.e.,
records).


\index{basic type}
\index{type!basic}
The basic typs have a \emph{singleton} object (for instance \texttt{StringType.TYPE}),
which is used as actual parameter whenever that is needed, for examp,e to
define the return type of a procedure or the type of a field in a
struct. The is no singleton and its constructor has an integer parameter
which is the index of the struct for which this type is a reference. The
\texttt{RefType} is use by creating an object with the index (\texttt{id}) for the struct
as the single parameter. One may make many such objects for the same type
(the same index) if that is more conventient, or just reuse the same object
for the type. An object of the reference type to the struct \texttt{"Complex"} can
be created like this.


\lstset{language=java,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
CodeFile cf = <...> ;
...
cf.addStruct("Complex");
...
RefType rt =  new RefType(cf.structNumber("Complex");
\end{lstlisting}



\subsubsection{Virtual machone listing of the example from earlier in this section}
\label{sec:org8bb26c1}

\begin{verbatim}
Loading from file: ./example.bin
Variables:
0: var Complex myGlobalVar
Procedures:
0: func void print_float()
1: func void Main()
   0: return
2: func void test(float 0, Complex 1, float 2)
   0: loadlocal 0
   3: call printfloat {0}
   6: return
Structs:
0: Complex
   0: float
   1: float
Constants:
STARTWITH: Main
\end{verbatim}
\section{How the interpeter works}
\label{sec:org72e99db}

\index{loader}
When the virtual machine is started, the interpreter is set up by the
loader. It has a variable pool, which holds the type of each global
variable. It has a procedure pool, which contains all the procedures: their
parameter and local variable types, return type, and instructions. It has a
struct pool with the layout of the structs; their names and the types (but
not names) of the fields. It also has a constant pool with all the
constants from the byte code file. All these pools are indexed by bumbers
(\texttt{id} s) which are the numbers used by the instructions.

When the interpreter is started, space is allocated for the global
variables and they are initialized with the initial values for their types
(see further down for more information about initial values). The a \emph{stack}
and a \emph{heap} is created and an \emph{activation block} for the main procedure is
created as well. Then the interpreter starts interpreting the byte code of
that procedure at the first byte (setting the program counter (\texttt{pc}) to
\(0\))
\index{program counter}
\index{stack}
\index{heap}
\index{activation block}


The instructions do things like loading a global variable onto the stack
(\texttt{LOADGLOBAL}), The \texttt{LOADGLOBAL} instructions has 2 extra bytes which
contain the id of the variable to push to the stack from the global
variables. When that instruction is performed, the program \texttt{pc} must be
incremented by 3 to move to the next instruction. The increment differs
from instruction to instruction and is listed as the \emph{size} in the table
with all instruction in Section XXX. Another instruction is \texttt{ADD} for
addition. When that is interpreter, the two values on top of the stack are
added up. Which kind of addition is done depends on the types of the two
summands on the stack, determined at run-time. The result if the
corresponding addition is pushed to the stack, and since the size is only
one (the instruction byte only), 1 is added to the program counter.


\index{block level}

\emph{Block levels} are not supported by the virtual machine and only either
global or else local variables can be accessed (\texttt{LOADGLOBAL}, \texttt{LOADLOCAL},
\texttt{STOREGLOBAL}, \texttt{STORELOCAL}). All names for procedures, structs, and
variables must be unique. A procedure must always end with a \texttt{RETURN}
instruction. If a procedure found in the binary file at loadtime is without
instruction, it is assumed to be a library procedure and a cll to it
results in a lookup using a table of library procedures.

\index{initial value}
All variables (global and local ones, as well as field in structs) are
allocated with initial values, which depend on their types. An integer is
set to \(0\) a float to \(0.0\), a string to the empty string, and a reference
is set to the null reference.

\subsection{Calling a procedure}
\label{sec:orge57a95a}

A procedure is alled with the \texttt{CALL} insturction. The byte instruction is
followed by the index of the procedure being caled. The interpreter locates
the procedure by using the intext, creates an activation block from the
information it has, initializes the local variables, saves the program
counter, and sets the program counter to the first byte of the called
function.

\subsection{Return}
\label{sec:org92034a5}
\index{return}
The activation blcok is popped off the stack and the program counter is set
to where it was before the corresponding call. The return value, which the
called precedure left on the statck, is again left on the top of the stack
for the calling procedure.


\subsection{Jumping}
\label{sec:org408b4e4}

\index{jump}

Jumping is simply done by setting the program counter to the byte with the
number that accompagnies the jump instruction. This is always a local
address \emph{within} a procedure's instruction bytes.
\index{local address}


\subsection{Treating records}
\label{sec:orgcc9c1d1}
\subsubsection{Allocating a struct on the heap}
\label{sec:org0506cbc}
When a struct is allocated on the heap, using the \texttt{NEW} instruction, a
reference is left in the stack that can be passsed around and saved in
variables. The \texttt{NEW} instruction is followed by the index of the struct to
allocate.


\subsubsection{Get and put fields}
\label{sec:org53bf3d7}


The instruction \texttt{GETFIELD} is followed by the index of the struct and the
index of the field within the that stuct. When it is interpreted, the
interpreter assumes that a reference to the struct is on top of the stack
and that reference is then popped off from the stack, The heap is
instructed to get the value of the field witin the struct and the
interpreter pushes the value of the field onto the stack, If the reference
is the null reference, the interpreter is aborted with an error message.
\section{Some typical tasks}
\label{sec:orga85af9a}
\label{org679199e}


In this section we show how some of the usual tasks are solved. As already
been show, some of the instruction classes are created by supplyijng one or
two interger values, which are the ids of procedures, structs, variables or
something that is to be used when the intruction is interpreted. For
instance, the \texttt{JMP} instruction is created with an integer parameter which
is the index of the instruction to be jumped to.  When an instruction is
added to the stream of bytes, it is followed by these indices coded into
\(0\) to \(4\) bytes, depending on the size needed. In this way a ``byte'' can
be \(1\) to \(5\) bytes long.
\section{Instructions}
\label{sec:org0a2c8aa}


Below is the table with all instructions supported by the virtual machine
and that can be found int the bytecode library. We use \(s_0\) for the top of
the stac, \(s_i\) for the next element, and so on. When the symbol
\(\moredetails\) (dagger) is found after the tanme of the instruction, we
mean that are are more details on the types of what is on the stack at the
end of this section (look up the instruction there).
\section{Finally, remember this.}
\label{sec:org4ef853f}
\label{orge4c0527}

To sum up, here are some important points to remember

\begin{itemize}
\item Always add a return statement to the end of the instructions of a
procedure.
\item Always set the main method
\item add the library procedures (like \texttt{print\_int} etc.) as procedures, but
without instructions
\item if the reference on the stack is a null reference when trying to access a
field of it, the interpreter will print the error \texttt{Nullpointer at
  GETFIELD} or the equivalent message for \texttt{PUTFIELD}, and the virtual
machine will abort.
\item do not hust add, but remember to update procedures, structs, and global
variables.
\item use the \emph{list} option (\texttt{-l}) to inspect your bytecode and even take a
look at it with an hex editor.
\end{itemize}
\end{document}