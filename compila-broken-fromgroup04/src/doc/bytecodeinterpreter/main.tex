% Created 2023-02-10 Fri 13:53
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\input{preamble}
\input{macros}
\author{Fredrik Sørensen, Stein Krogdahl, Birger Møller-Pedersen}
\date{Spring semester 2021}
\title{Bytecode interpreter}
\hypersetup{
 pdfauthor={Fredrik Sørensen, Stein Krogdahl, Birger Møller-Pedersen},
 pdftitle={Bytecode interpreter},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 24.3.1 (Org mode 9.2)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Introduction}
\label{sec:org53621b7}

This report presents the local variant of a library for \emph{bytecode
construction and interpretation} written for the compiler construction
course INF5110 at the University of Oslo.  The objective of this exercise
is to write a compiler for a simple example language. The bytecode library
and intepreter were developed to be used in the \emph{code generation} and
\emph{runtime} part of the obligatory exercises in the course.


Bytecode instructions are in general similar to instructions in machine
code, but instead of being run directly on a machine, they are usually
interpreted by a bytecode interpreter. Alternatively, they may also be
translated into machine code before being run. A bytpecode instruction
library is a library to simplify the task of generating bytecode for a
bytecode interpreter. The terminology "bytecode" comes from the fact that
the size of each instruction one single byte.

Our bytecode is quite similar to Java bytecode and our bytecode library is
based on the \href{http://commons.apache.org/proper/commons-bcel/}{Byte Code Engineering Library}.\footnote{\texttt{http://commons.apache.org/proper/commons-bcel/}, formerly as
part of the Jakarta project.} We choose to write a
simpler, stripped-down version that, for instance, does not support
classes, virtual procedures, and many other features supported by Java's
bytecode.  This way, it's simpler to work with and there would be less
code. For instance, one does not need to create classes like, since our
language does not have them, just for ``some reasons unexplained''. Still,
we encourage students to look at BCEL, it's a nice and well designed tool



The bytecode library and the interpreter are, not surprisingly, written in
Java. All the code is written in source form and consists of the following
packages.


\begin{center}
\begin{tabular}{ll}
\hline
package & purpose\\
\hline
\texttt{bytecode.*} & classes to create bytecode\\
\texttt{bytecode.instructions.*} & instruction classes, supporting the above\\
\texttt{bytecode.type.*} & classes for types, supporting the above\\
\texttt{runtime.*} & classes for the runtime system\\
\hline
\end{tabular}

\end{center}

The code for the two packages \texttt{bytecode} and \texttt{runtime} is found in the
corresponding two directories under \texttt{./src}

\subsection{The interpreter}
\label{sec:org686784d}

The interpreter is \emph{stack based} and it interprets about 40 different
instructions of our bytecode.  The interpreter ``automatically'' handles
allocation of struct types, method calls and access of variables in a
struct when instructed to by the bytecode instructions. In the current
version, there is \textbf{no garbage collector} and it just allocates memory
sequentially as long as there is memory left.

\index{instruction}
\index{operation}

The operators or instructions are so called \textbf{stack operations}. It means
that whe the intpreter executes an instruction, it pops off a number of
operands from the stack (0 or more), performs the task specified by the
instruction, and leaves a number of result values on the stack, typically
just one such value.

The interpreter is not written for efficiency, by rather for readability
and ease of creating runnable bytecode. For instance, the types are kept on
the stack together with the calculated values and the interpreter decides
what kind of operation to perform based on the types as well as the current
instruction. For example, an \texttt{ADD} instruction, representing addition, will
be performed differently if there are two integers on the stack, two
floats, or one of each. That's different from Java bytecode, which has an
\texttt{ADDINT} and an \texttt{ADDFLOAT} instruction and where type casting has to be
done explicitly in the bytecode (for example with the \texttt{i2f} instruction,
which does the corresponding conversion).

\subsection{Interpreting bytecode}
\label{sec:orgb89cde5}


As said, the interpreter is stack-based. We are not talking here about the
run-time stack of the run-time environment, but the P-code like treatment
of instruction. Of course, the interpreter must realize also some stack
organizing calls and returns, scoping, and parameter passing.


The parameters of an an operation (including user-defined functions) must
be placed on the stack with \textbf{the leftmost at the bottom and the rightmost
on the top} of the stack before the instruction itself is interpreted. The
top of the stack is the place where one pushes into and pops off. In the
lecture, in the part of the run-time environments, the run-time stack was
perhaps confusingly \emph{depicted} with the top the stack at the bottom.

For example, the \texttt{SUB} instruction (for subtraction) requires that the two
operands of the \texttt{SUB} instruction are on the stack in the correct order
beforehand. The number to subtract must be on the top of the stack and the
number to subtract from deeper in the stack. We may denote the elements on
the stack before an instruction is interpreted with \(s_n\), where \(n\) is the
index from the top, with the top as \(n = 0\). Then, the result of the \texttt{SUB}
instruction is that the two values on the top of the stack is removed and
replaced by \(s_1 - s_0\). 

\subsection{The library}
\label{sec:org14a1282}

The library has a class  \href{../../bytecode/CodeFile.java}{\texttt{CodeFile}} that is the base class for creating a
program with ``runnable'' sequences of instructions, i.e. a (binary or
\texttt{.bin}) file, executable by the virtual machine or more specifically by the
virtual machine interpreter.


To create such a bytecode file, one must instantiate that class \texttt{CodeFile}
and \textbf{add} procedures, structs and global variables using the procedures of
the \texttt{CodeFile} object. Objects that represent local variables and
instructions are created using the library and added to the procedure
objects, which are of class \texttt{CodeProcedure}. When the program is complete,
that is, when all the elements of the program has been added to the
\texttt{CodeFile} object and its \texttt{CodeProcedure} objects, the actual bytecode can
be extracted by the procedure \texttt{getBytecode()} of a \texttt{CodeFile} object.  The
array of bytes that is then created, is usually written to a file, which
can then be read by the virtual machine and run by its interpreter.



A typical use of an instance of \texttt{CodeFile} will be something like this:


\lstset{language=java,label= ,caption={Typical use of the \texttt{Codefile} class},captionpos=b,numbers=none}
\begin{lstlisting}
CodeFile codeFile = new CodeFile();
String filename = "example.bin";

// Building the bytecode with instructions 
// like the following:
codeFile.addProcedure("Main");
CodeProcedure main = 
   new CodeProcedure("Main",
   	              VoidType.TYPE,
		      codeFile);
main.addInstruction (new RETURN());
codeFile.updateProcedure(main);

// ... and more ....

byte [] bytecode = codeFile.getBytecode();  // bytecode = array of bytes.
DataOutputStream stream = 
   new DataOutputStream(new FileOuputStream(filename));
stream.write(bytecode);
stream.close();
\end{lstlisting}

In that example, first an object of the class \texttt{CodeFile} is created. Then,
the procedure \texttt{"main"} is added. More procedures, structs, global
variables, and constants may be added to it. Then one can get the bytecode,
which is an array of bytes, and write it to a file, as shown in the code
snippet.

The generated bytecode file can then be inspected, for instance with an
editor for binary files like the Eclipse Hex Editor Plugin (\href{http://ehep.sourceforge.net/}{EHEP}).\footnote{For Ehep, see \texttt{http://ehep.sourceforge.net/} or
\texttt{https://marketplace.eclipse.org/content/ehep-eclipse-hex-editor-plugin}.}

\subsection{Using the virtual machine}
\label{sec:org932f857}

A bytecode file can be used in two ways, file, both offered by the class
\href{../../runtime/VirtualMachine.java}{\texttt{VirtualMachine}} of the \href{../../runtime/}{\texttt{runtime}} package. Either the execution is
triggered \emph{externally}, from the \textbf{command line}. Or internally from within
a Java program. For the exernal use, the command line commands are


\begin{verbatim}
  java runtime.VirtualMachine <FILENAME>
\end{verbatim}

Using the interpreter from inside a program, one needs to instantiate the
class \href{../../runtime/VirtualMachine.java}{\texttt{VirtualMachine}} and call its \texttt{run} method.

\lstset{language=java,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
  VirtualMachine vm = new VirtualMachine("<FILENAME>");
  vm.run();
\end{lstlisting}

The class \texttt{VirtualMachine} can also list the content of the bytecode file
in textual form. Eexternally with the command line option \texttt{-l} or, from
inside a program, using the \texttt{list} method:

\begin{verbatim}
  java runtime.VirtualMachine -l <FILENAME>
\end{verbatim}

resp.

\lstset{language=java,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
  VirtualMachine vm = new VirtualMachine("<FILENAME>");
  vm.list();
\end{lstlisting}

As an example, assume a program like this

\lstset{language=java,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
// File: ./Simple.d
struct Complex {
  var float Real;
  var float Imag;
}

var Complex dummy;
func Main () { }
\end{lstlisting}

Listing the generated bytecode with the \texttt{-l} option would then look as
follows.

\begin{verbatim}
Loading from file: ./Simple.bin
Variables:
0: var Complex dummy
Procedures:
0: Main()
   0: return
Structs:
0: Complex
     0: float
     1: float
Constants:
STARTWITH: Main
\end{verbatim}



\subsection{Source code overview}
\label{sec:org764fd8e}

The \href{../../bytecode/}{bytecode library} is a package contain a few classes and besides that
sub-packages with their own classes. The most important classes at the
top-level the library are the following

\begin{center}
\begin{tabular}{ll}
class & purpose\\
\hline
\href{../../bytecode/CodeFile.java}{\texttt{CodeFile}} & main class to create byte code\\
\href{../../bytecode/CodeProcedure.java}{\texttt{CodeProcedure}} & create code for procedures\\
\href{../../bytecode/CodeStruct.java}{\texttt{CodeStruct}} & create code for structs\\
\end{tabular}

\end{center}

The first one is the the main class for creating byte code, mentioned
earlier, the other two for creating a procedure resp. a struct in the byte
code.


There are two sub-packages, contained in corresponding sub-directories


\begin{center}
\begin{tabular}{ll}
sub-package & purpose\\
\hline
\href{../../bytecode/./instructions/}{\texttt{instructions}} & byte code instruction set\\
\href{../../bytecode/type/}{\texttt{type}} & byte code representation of the types\\
\hline
\end{tabular}

\end{center}


The packages are referred to accordingly \texttt{bytecode.instructions.*} and
\texttt{bytecode.type.*}.  The instructions in the first package are represented
as concrete subclasses of the abstract \href{../../bytecode/./instructions/Instruction.java}{\texttt{Instruction}} class.  Similarly for
the types (as subclasses of the abstract \href{../../bytecode/./type/CodeType.java}{\texttt{CodeType}} class. That package
contains all the types used in the byte code.

Although usually not directly used by a programmer, it might be instructive
to know the main classes of the virtual machine resp. the run-time system,
as well. See the package resp. directory \href{../../runtime/}{\texttt{runtime}} The main classes are the
following:

\begin{center}
\begin{tabular}{l}
class (in \texttt{runtime})\\
\hline
\href{../../runtime/VirtualMachine.java}{\texttt{VirtualMachine}}\\
\href{../../runtime/Interpreter.java}{\texttt{Interpreter}}\\
\href{../../runtime/Stack.java}{\texttt{Stack}}\\
\href{../../runtime/Heap.java}{\texttt{Heap}}\\
\href{../../runtime/ActivationBlock.java}{\texttt{ActivationBlock}}\\
\href{../../runtime/Loader.java}{\texttt{Loader}}\\
\\
\end{tabular}

\end{center}

The virtual machine class is the starting point for running a program, as
mentioned earlier.  The loader class loads a a program from a file. The
actual interpretation of the byte code is provided by the interpreter
class. The classes \texttt{Heap} and \texttt{Stack} are responsible for management of the
corresponding memory. Note that there is a single stack for each program
(as the programs are single-threaded). The heap contains structs, and their
allocation and access is maintained by the mentioned class. The class for
activation blocks handles and stores the program counter, local variables
etc. and also handles the call and return of a procedure in conjuction with
the interpreter.


[Add some more from the original]


\section{Building a complete program}
\label{sec:org94183b9}
\label{orgf36f364}     

We have shown the basics of how to build a bytecode program (binary file)
using the bytecode library. In this section we will show some of the
details by covering each of the classes of the library. Details about all
the instructions will come in Section \ref{org7f406a6}.

The main parts for creating a new program are: create an object of the
class \texttt{CodeFile}. Afterwards add the procedures, i.e., objects of class
\texttt{CodeProcedure}, structs, i.e., objects of class \texttt{CodeStruct}, and so
on. Finally, when calling the \texttt{getBytecode()} procedure, the bytecode
library will generae the actual bytes from the object hat have been created
and from the ``properties'' given to those objects. Note that there a
\emph{four} steps to create a procedure (or a struct, or global variable).

\begin{center}
\begin{tabular}{rll}
 &  & \\
\hline
1. & \emph{add} the definition to the \texttt{CodeFile} object & \texttt{addProcedure}.\\
2. & \emph{create} the \texttt{CodeProcedure} object (say \texttt{p}) & \texttt{new CodeProcedure}.\\
3. & \emph{add} ``properties'', such as  instructions, to \texttt{p} & \\
4. & \emph{update} the \texttt{CodeProcedure} object in the \texttt{CodeFile} & \texttt{updateProcedure}\\
\end{tabular}

\end{center}



These four standard steps are illustrated in slightly more detail in the
following example.

\subsection{Creating code for a procedure: A small example.}
\label{sec:org25e9633}

The example code creates a "code file" and first adds the name of a
\emph{library} procedure to be used.  It then adds 4 items, in preparation for
the follow-up steps, which add the code for those items. Added is procedure
\texttt{Main}, a global variable \texttt{myGlobalVar}, a procedure \texttt{test} and a struct
\texttt{Complex} (I).


In the next steps, the procedure \texttt{Main} is properly defined and the
information is added. The main procedure has the void return type, no
parameters, no local variables and the body consists of a single
instruction, namely \texttt{return}. The code of part (II) corresponds to the
steps 2.-4. for the 4 steps mentioned above, the first step for the
procedure has been done in "section" (I).

The global variable is typed with the struct type \texttt{Complex} (III).

The procedure \texttt{test} has 2 parameters (of type float and a reference type
to \texttt{Complex}). The procedure loads the first parameter onto the stack and
then calls the (library) procedure \texttt{print\_float} to print its value
(IV). The struct \texttt{Complex} is created and the two fields, both of floating
point type, are added to it (V). The procedure \texttt{print\_float} used in the
program is a library procedure. Nonetheless, it needs to be added, but
without instructions (VI). See also Section
\ref{org1c2cbfd}. Finally, the mandatory main method is set,
before the bytecode can be extracted to a file (VII). Section
\ref{org629e8fd} later shows the generated machine code for
this example.

\lstset{language=java,label=org96fcbfd,caption={4 steps to generate code for a procedure},captionpos=b,numbers=none}
\begin{lstlisting}
// Make code:
CodeFile codeFile = new CodeFile();
codeFile.addProcedure("printFloat")

//-------  (I) ---------------------
codeFile.addProcedure("Main");
codeFile.addVariable("myGlobalVar");
codeFile.addProcedure("test");
codeFile.addStruct("Complex");
//-------- (II) --------------
CodeProcedure main = 
    new CodeProcedure("Main", 
		      VoidType.TYPE, 	     
		      codeFile);
main.addInstruction(new RETURN());
codeFile.updateProcedure(main);

//--------- (III) -------------
codeFile.updateVariable("myGlobalVar",
		         new RefType(codeFile.structNumber("Complex")));
//---------- (IV) -------------
CodeProcedure test = new CodeProcedure("test",
				       VoidType.TYPE,
				       codefile);
test.addParameter("firstPar", FloatType.TYPE);
test.addParameter("secondPar", new RefType(test.structNumber("Complex")));
test.addInstruction(new LOADLOCAL(test.variableNumber("firstPar")));
test.addInstruction(new CALL(test.procedureNumber("print_float")));
test.addInstruction(new RETURN());
codeFile.updateProcedure(test);

//---------- (V) ----------------

CodeStruct complex =  new Codestruct("Complex");
complex.addVariable("Real", FloatType.TYPE);
complex.addVariable("Imag", FloatType.TYPE);
codeFile.updateStruct(complex);

//----------- (VI) --------------
CodeProcedure printFloat = new CodeProcedure("print_float",
					     VoidType.TYPE, 
					     codeFile);
test.addParameter("f", FloatType.TYPE);
codeFile.updateProcedure(printFloat);

//----------- (VII) --------------
codeFile.setMain("Main");
byte[] bytecode = codeFile.getBytecode();
//.............. write the bytes to a file
\end{lstlisting}


\subsubsection{Class \texttt{CodeFile}}
\label{sec:org6a74ac8}


\index{error: classes are not created}

This is the class byecode is created from and all elements must be added to
the corresponding object. It also provides the service of returning indices
to the given elements, as we will see later. Those indices are needed when
instruction classes are created. They reference the elements within the
program. Adding something to a \texttt{CodeFile} object is done in \emph{two} stages;
first, the element is added using something like the \texttt{addProcedure}
procedure, supplying only the name. Then later, the \texttt{updateProcedure} must
be called with a reference to the actual procedure object. After a
procedure has been added (but before it has been updated) its index can be
found and used, for example to create a call to it, as we will see.


An object of the \texttt{CodeFile} class is typically seen by all the nodes in the
abstract syntax tree, by for example passign around a reference to it. An
element in the syntax tree is typically responsible for adding itself to
the compiled result by using the procedures of the \texttt{CodeFile} or
\texttt{CodeProcedure} classes.

\index{index}

\index{global variable}
A \emph{global variable} is added by using the procedure \texttt{void
addVariable(String name)}. After a global variable has been added, its
index (\texttt{id}) in the program may be found using its name, calling the
procedure \texttt{int globalVariableNumber(String name)} The type of the variable
\emph{must} be supplied \emph{before} the bytecode is generated. The generation is
done by calling the method \texttt{void updateVariable(String name, CodeType
type)}. All global variables must have unique names.

\index{procedure}

A \emph{procedure} is added by using the procedure \texttt{void addProcedure(String
name)} After a procedure has been added, its index (\texttt{id}) in the program
can be found using its name, calling the method \texttt{int procedureNumber(String
name)}. The details of the procedure must be supplied before the bytecode
is generated. That  is done by invoking the method \texttt{public void
updateProcedure(CodeProcedure codeProcedure)}.

\index{struct}

For a struct, there are analogous procedures \texttt{public void addStruct(String
name)}, \texttt{int structNumber(String name)}, and \texttt{void updateStruct (CodeStruct
codeStruct)}.  In addition, getting the index of a field in a struct is
done by calling \texttt{int fieldNumber(String structName, String varName)} using
the name of the struct and the name of the field.

A \texttt{string constant} is added by using the procedure \texttt{int
addStringConstant(String value)}. Note that this procdure returns the index
(\texttt{id}) of the constant \emph{directly} and there is no procedire to fetch the
index of a constant later.  The index is used for string literals by the
compiler.

\index{string literal}

After all the elements are added, it is important to let the interpreter
know which procedure to start with. This is done by using the the name of
the procedure (typically \texttt{"main"}) and calling \texttt{void SetMain(String name)}.

\index{main procedure}

\subsubsection{Class \texttt{CodeProcedure}}
\label{sec:org049fb84}

A procedure in the program is made by first adding its name to the
\texttt{CodeFile} object, then creating an object of this class, then adding the
parameters, local variables, and instructions to the object, and finally by
updating the \texttt{CodeFile} object with the \texttt{CodeProcedure} object.

\index{procedure object}
A \emph{procedure object} is creatd by the constructor \texttt{CodeProcedure(String
name, CodeType returnType, CodeFile codeFile)}. This takes the unique name
of the procedure, the return type (see \texttt{CodeType} below) and the code file
that it will be added to. The reason why the code file is included is that
it is needed by the procedure object to provide some of the code file
services (relying on a delegation pattern mechanism).

\index{delegation}

\index{parameter}
\index{local variable}

\emph{Parameters} and \emph{local variables} are added by the procedures \texttt{void
addParameter(String name, CodeType type)} and  \texttt{void addLocalVariable(String
name, CodeType type)}.

\index{instruction}

\index{replace an instruction}
\index{instruction!replacement}
An \emph{instruction} is added to the procedure object with \texttt{int
addInstruction(Instruction instruction)}. The return value of this method
is the \emph{index} of the instruction in the procedure's list of
instructions. Sometimes one wants to \emph{replace} and earlier
instruction. This is done by using \texttt{void replaceInstruction(int place,
Instruction instruction)}. For instance, one may insert temporarily a \texttt{NOP}
instruction to be replaced later by a jump instruction \texttt{JMP}. Read more in
Section  \ref{org8399359} on jumps. A procedure body cannot be
completely empty, it must at least contain one final \texttt{RETURN}
instruction.
\index{return}

\index{jump}

\index{index}

The \emph{index} of a variable or a parameter can be found by using \texttt{int
variableNumber(String name)}. Note that local variables mus have unique
names in any block, and that includes the parameters. The parameters are
given the first indices from left to right, starting from \texttt{0}. The
(remaining) local variables are given the subsequent indices in the order
of their declaration.

A \texttt{CodeProcedure} object can find the indices of elements using its
\texttt{CodeFile} object, so it also has the procedures \texttt{globalVariableNumber},
\texttt{procedureNumber}, \texttt{structNumber}, and \texttt{fieldNumber}. It also has and
delegates the \texttt{addStringConstant} procedure.


\subsubsection{Class \texttt{CodeStruct}}
\label{sec:orge892e0f}

\index{struct}

A \emph{struct} is created with the constructor \texttt{CodeStruct(String name)}
providing the name of the struct. A field is added to the struct by using
\texttt{void addVariable(String name, CodeType type)}. To retrieve the index of a
field added to the struct, one may use \texttt{int fieldNumber(String name)}. See
also the \texttt{fieldNumber} procedure of \texttt{CodeFile}.


\subsubsection{Subpackage for types}
\label{sec:orga81388e}
\paragraph{Class \texttt{CodeType}}
\label{sec:org95d6079}
\index{type}

This is an abstract class and it has as concrete subclasses the different
classes of types: \texttt{VoidType}, \texttt{BoolType}, \texttt{IntType}, \texttt{FloatType},
\texttt{StringType} and \texttt{RefType}. The void type is used for procedures that don't
return a value and the reference type is for references to structs (i.e.,
records).


\index{basic type}
\index{type!basic}
The basic types have a \emph{singleton} object (for instance \texttt{StringType.TYPE}),
which is used as actual parameter whenever needed, for example to define
the return type of a procedure or the type of a field in a struct.


The \texttt{RefType} class is a little different. There is no singleton and its
constructor has an integer parameter which is the \emph{index} of the struct for
which this type is a reference. The \texttt{RefType} is use by creating an object
with the index (\texttt{id}) for the struct as the single parameter. One may make
many such objects for the same type (the same index) if that is more
convenient, or just reuse the same object for the type. An object of the
reference type to the struct \texttt{"Complex"} mentioned before, for example, can
be created like this.


\lstset{language=java,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
CodeFile cf = <...> ;
...
cf.addStruct("Complex");
...
RefType rt =  new RefType(cf.structNumber("Complex");
\end{lstlisting}



\subsection{Virtual machine listing}
\label{sec:org1e8983d}
\label{org629e8fd}   


The following shows the code corresponding to the example from earlier in
the section.

\begin{verbatim}
Loading from file: ./example.bin
Variables:
0: var Complex myGlobalVar
Procedures:
0: func void print_float()
1: func void Main()
   0: return
2: func void test(float 0, Complex 1, float 2)
   0: loadlocal 0
   3: call printfloat {0}
   6: return
Structs:
0: Complex
   0: float
   1: float
Constants:
STARTWITH: Main
\end{verbatim}
\section{How the interpeter works}
\label{sec:org6832c05}
\label{orgdfdbe1b}       

\index{loader}
\index{virtual machine}
\index{variable pool}
\index{procedure pool}
\index{struct pool}
\index{constant pool}
When the virtual machine is started, the interpreter is set up by the
\emph{loader.} It has a variable pool, which holds the type of each global
variable. It has a procedure pool, which contains all the procedures: their
parameter and local variable types, return type, and instructions. It has a
struct pool with the layout of the structs; their names and the types (but
not names) of the fields. It also has a constant pool with all the
constants from the byte code file. All these pools are indexed by numbers
(\texttt{id} s) which are the numbers used by the instructions.

\index{allocation}

When the interpreter is started, space is allocated for the global
variables and they are initialized with the initial values for their types
(see further down for more information about initial values). The a \emph{stack}
and a \emph{heap} are created and an \emph{activation block} for the main procedure
is created as well. Then the interpreter starts interpreting the byte code
of that procedure at the first byte, setting the program counter \texttt{pc} to
\(0\)

\index{program counter}
\index{stack}
\index{heap}
\index{activation block}


The instructions do things like loading a global variable onto the stack
(\texttt{LOADGLOBAL}), The \texttt{LOADGLOBAL} instructions has 2 extra bytes which
contain the id of the variable to push to the stack from the global
variables. When that instruction is performed, the program counter \texttt{pc}
must be incremented by 3 to move to the next instruction. The increment
differs from instruction to instruction and is listed as the \emph{size} in the
table with all instructions in Section \ref{org20ead7f}. Another
instruction is \texttt{ADD} for addition. When that is interpreted, the two values
on top of the stack are added up. Which kind of addition is done depends on
the types of the two summands on the stack, determined at run-time. The
result of the addition is pushed to the stack, and since the size is only
one (the instruction byte only), 1 is added to the program counter.


\index{block level}

\emph{Block levels} are not supported by the virtual machine and only either
global or else local variables can be accessed (\texttt{LOADGLOBAL}, \texttt{LOADLOCAL},
\texttt{STOREGLOBAL}, \texttt{STORELOCAL}). All names for procedures, structs, and
variables must be \emph{unique}. A procedure must always end with a \texttt{RETURN}
instruction. If a procedure found in the binary file at loadtime is without
instructions, it is assumed to be a library procedure and a cll to it
results in a lookup using a table of library procedures.
\index{library}

\index{initial value}
All variables (global and local ones, as well as field in structs) are
allocated with initial values, which depend on their types. An integer is
set to \(0\) a float to \(0.0\), a string to the empty string, and a reference
is set to the null reference.

\subsection{Calling a procedure}
\label{sec:org655b598}

\index{procedure call}

A procedure is called with the \texttt{CALL} insturction. The byte instruction is
followed by the index of the procedure being called. The interpreter
locates the procedure by using the intext, creates an \emph{activation block} from
the information it has, initializes the local variables, saves the program
counter, and sets the program counter to the first byte of the called
function.

\subsection{Return}
\label{sec:org0ae8ade}
\index{return}

The activation blcok is popped off the stack and the program counter is set
to where it was before the corresponding call. The return value, which the
called precedure left on the statck, is again left on the top of the stack
for the calling procedure.


\subsection{Jumping}
\label{sec:org0860850}

\index{jump}

Jumping is simply done by setting the program counter to the byte with the
number that accompagnies the jump instruction. This is always a local
address \emph{within} a procedure's instruction bytes.
\index{local address}


\subsection{Treating records}
\label{sec:orgf7e13e2}
\subsubsection{Allocating a struct on the heap}
\label{sec:org3a5a0ce}

\index{struct}
When a struct is allocated on the heap, using the \texttt{NEW} instruction, a
reference is left on the stack that can be passsed around and saved in
variables. The \texttt{NEW} instruction is followed by the index of the struct
type to allocate.


\subsubsection{Get and put fields}
\label{sec:org8c3be2f}

\index{field}

The instruction \texttt{GETFIELD} is followed by the index of the struct and the
index of the field within the that stuct. When it is interpreted, the
interpreter assumes that a reference to the struct is on top of the stack
and that reference is then popped off from the stack, The heap is
instructed to get the value of the field witin the struct and the
interpreter pushes the value of the field onto the stack, If the reference
is the null reference, the interpreter aborts with an error message.
\section{Some typical tasks}
\label{sec:org6d2026e}
\label{org39ea8cd}


This section show some of the usual tasks. As already shown, one can obtain
instructions by instantiating the corresponding class and supplying one or
two integer values which are the ids of procedures, structs, variables or
something to be used when the intruction is interpreted. For instance, the
\texttt{JMP} instruction is created with an integer parameter which is the index
of the instruction to be jumped to.  When an instruction is added to the
stream of bytes, it is followed by these indices coded into \(0\) to \(4\)
bytes, depending on the size needed. In this way a ``byte'' can be \(1\) to
\(5\) bytes long.


\subsection{Calling a procedure}
\label{sec:org664dc5e}

The constructor of the \texttt{CALL} class has an integer parameter
\texttt{funcNum}. That is the index of the procedure and can be gotten from a
\texttt{CodeFile} object if the procedure has been added. So a call instruction is
created and added to the list of instructions. See the corresponding line
in the example of Listing \ref{org96fcbfd}:

\lstset{language=java,label=orge905268,caption= ,captionpos=b,numbers=none,firstline=15, lastline=16}
\begin{lstlisting}
test.addInstruction(new CALL(test.procedureNumber("print_float")));
\end{lstlisting}



\subsection{Jumping}
\label{sec:org5614f8e}
\label{org8399359}

The constructore of the \texttt{JMP} class has an integer parameter \texttt{jumpTo}. This
is the index that the instraction has in the list of the instructions of
this procedure. To way to get the index of an instruction is to save the
integer returned from the \texttt{addInstruction} method. A trick fro placing
\emph{labels} in the code is to add a dummy instruction \texttt{NOP} at a place where
one wants to insert a jump or wants to jump to. For example, the following
creates the code for an infinite loop.



\lstset{language=java,label=orgfeba2e2,caption={Infinite loop},captionpos=b,numbers=none}
\begin{lstlisting}
int top = test.addInstruction(new NOP());
// here code for the body of the infinite loop could be added.
test.addInstruction(new JMP(top));
\end{lstlisting}

\textbf{Important:} the numbers used in the cosntructor for \texttt{JMP} and the
conditional jump classes are the index of the instruction in the list of
instructions. In this list, all instructions are considered to have size
one. This is so that there will be no problems when replacing an
instruction with another of a different size. When the bytecode is created
and a new number is calculated and replaces that number (for all jumps)
with the actual address withing the byte array, since at run-time the
instructions with accompagnying operand values have different sizes.

\subsection{Conditional jumps}
\label{sec:org08f6eaa}

The work simular to unconditional jumps, but there has to be a boolean
value on the stack, when executed.  Whether or not the jump is executed
depends on the value of that boolean. For instance, the following creates
the code for a do-while loop. More concretely for a loop of the form in
some pseudo-code:.

\begin{verbatim}
do {
// loop body
} while (i<2);
\end{verbatim}




\lstset{language=java,label=orgf9ec241,caption={do-while loop},captionpos=b,numbers=none}
\begin{lstlisting}
int start = test.addInstruction(new NOP());  // jump target = loop start
                                             // statements for loop body....
test.addInstruction(new LOADLOCAL(test.variableNumber("i")));
test.addInstruction(new PUSHINT(new Integer(2)));
test.addInstruction(new LT());               // boolean value now on the stack
test.addInstruction(new JMPTRUE(start));     // jump back if true		    
\end{lstlisting}


\subsection{Library procedures}
\label{sec:org730892e}
\label{org1c2cbfd}


\index{library procedure}

When library procedures are needed, they may be added to the \texttt{CodeFile}
(and updated, the name alone is not enough), but no instruction should be
added, The interpreter recognizes the use of a library procedure by the
fact that it contains no instruction in the binary file (\texttt{CodeFile}).
\section{Finally, remember this.}
\label{sec:orgd8d8d72}
\label{org7f406a6}


To sum up, here are some important points to remember

\begin{itemize}
\item Always add a return statement to the end of the instructions of a
procedure.
\item Always set the main method.
\item add the library procedures (like \texttt{print\_int} etc.) as procedures, but
without instructions
\item if the reference on the stack is a null reference when trying to access a
field of it, the interpreter will print the error \texttt{Nullpointer at
  GETFIELD} or the equivalent message for \texttt{PUTFIELD}, and the virtual
machine will abort.
\item do not hust add, but remember to update procedures, structs, and global
variables.
\item use the \emph{list} option (\texttt{-l}) to inspect your bytecode and even take a
look at it with an hex editor.
\end{itemize}
\section{Instructions}
\label{sec:org986d14f}
\label{org20ead7f}

Below is the table with all instructions supported by the virtual machine
and that can be found int the bytecode library. We use \(s_0\) for the top of
the stac, \(s_i\) for the next element, and so on. When the symbol
\(\moredetails\) (dagger) is found after the tanme of the instruction, we
mean that are are more details on the types of what is on the stack at the
end of this section (look up the instruction there).


\subsection{Summary of the instructions}
\label{sec:org3b62caf}



\subsubsection{Binary operators}
\label{sec:orgf1a1b73}


They require two values on the stack and leave one there. They have \emph{no}
extra value. There are the following 14 binary operators: \texttt{ADD}, \texttt{AND},
\texttt{DIV}, \texttt{EQ}, \texttt{EXP}, \texttt{GT}, \texttt{GTEQ}, \texttt{LT} \texttt{LTEQ}, \texttt{MUL}, \texttt{NEG}, \texttt{NOR}, \texttt{OR},
\texttt{SUB}.

\subsubsection{Unary operators}
\label{sec:orgc7100af}




The numbers correspond to the \emph{opcodes}.    

\begin{longtable}{|l|c|p{3.5cm}|p{3cm}|p{3cm}|}
operator & nr. & extra bytes & before & after\\
\hline
\endfirsthead
\multicolumn{5}{l}{Continued from previous page} \\
\hline

operator & nr. & extra bytes & before & after \\

\hline
\endhead
\hline\multicolumn{5}{r}{Continued on next page} \\
\endfoot
\endlastfoot
\hline
\texttt{ADD} \(\moredetails\) & 01 & none & first operand \(s_1\), second operand \(s_0\), both: int, float, or string & \(s_1+s_0\)\\
\texttt{AND} & 02 & none & first operand \(s_1\), second operand \(s_0\), both: bool & \(s_1\land s_0\)\\
\texttt{CALL} \(\moredetails\) & 03 & 2 bytes (short), with the index (id) of the function & the parameters from the left \(s_n\) to the right \(s_0\) & value returned, if any\\
\texttt{DIV} \(\moredetails\) & 35 & none & the dividend \(s_1\) and the divisor \(s_0\), both int or float & \(s_1/s_0\)\\
\texttt{EQ} \(\moredetails\) & 04 & none & first operand \(s_1\), second operand \(s_0\), both: int, float, or bool & a boolean\\
\texttt{EXP} \(\moredetails\) & 05 & none & first operand \(s_1\), second operand \(s_0\), both: int or float & a float, result of \(s1s_0\)\\
\texttt{GETFIELD} & 06 & 4 bytes (2 shorts), index of the field within the struct and the index (id) of the struct & reference to the struct  \(s_0\) & the value of the field, if \(s_0\) is not a null reference\\
\texttt{GT} & 07 & none & first operand \(s_1\), second operand \(s_0\). Both: int or float & a boolean, result iff \(s_1 > s_0\)\\
\texttt{GTEQ} & 31 & none & first operand \(s_1\), second operand \(s_0\). Both: int or float & a boolean, result iff \(s_1 \geq s_0\)\\
\texttt{JMP} & 08 & 2 bytes (short) with the position in the bytes of the function to jump to & none & none\\
\texttt{JMPFALSE} & 09 & 2 bytes (short) with the position in the bytes of the function to jump to & a boolean \(s_0\). Jump only if false. & none\\
\texttt{JMPTRUE} & 10 & 2 bytes (short) with the position in the bytes of the function to jump to & a boolean \(s_0\). Jump only if true. & none\\
\texttt{LOADGLOBAL} & 11 & 2 bytes (a short) with the index (id) of the global variable to load. & none & the value of the global variable.\\
\texttt{LOADLOCAL} & 12 & 2 bytes (a short) with the index (id) of the local variable to load.  Remember params! & none & the value of the local variable.\\
\texttt{LOADOUTER} & 13 & 4 bytes & \textbf{Not implemented in this version. No support for block structure!} & \\
\texttt{LT} & 29 & none & first operand \(s_1\) and second operand \(s_0\). Both: int or float & a boolean: true iff \(s_1 < s_0\).\\
\texttt{LTEQ} & 30 & none & first operand \(s_1\) and second operand \(s_0\). Both: int or float & a boolean: true iff \(s_1 \leq s_0\).\\
\texttt{MUL} \(\moredetails\) & 34 & none & first operand \(s_1\), second operand \(s_0\), both: int, float & \(s_1*s_0\)\\
\texttt{NEQ} \(\moredetails\) & 32 & none & first operand \(s_1\), second operand \(s_0\), both: int, float, or bool & a boolean, result of \(s_1\noteq s_0\)\\
\texttt{NEW} & 14 & 2 bytes (a short) with the index (id) of the struct to create an instance of. & none & a reference to the newly created struct.\\
\texttt{NOP} & 15 & none & none & none, the instruction does nothing\\
\texttt{NOT} & 16 & none & a boolean, \(s_0\) & a boolean, \(\lnot s_0\)\\
\texttt{OR} & 02 & none & first operand \(s_1\), second operand \(s_0\), both: bool & \(s_1\lor s_0\)\\
\texttt{POP} & 28 & none & some value \(s_0\) & none, instruction removes the top\\
\texttt{PUSHBOOL} & 18 & 1 byte with the constant value 1 (true) or 0 (false) & none & the boolean constant from the extra byte\\
\texttt{PUSHFLOAT} & 19 & 4 bytes with the value of the float constant & none & the float constant from the extra bytes\\
\texttt{PUSHINT} & 20 & 4 byte with the value of the float constant & none & the integer constant from the extra bytes\\
\texttt{PUSHNULL} & 21 & none & none & a null reference\\
\texttt{PUSHSTRING} & 22 & 2 bytes (a short) with the index (id) of the string constant & none & the string constant\\
\texttt{PUTFIELD} & 23 & 4 bytes (2 shorts) which are the index of the field within the struct and the index (id) of the struct. & the vaue to assign to the field \(s_1\) and the reference to the struct \(s_0\) & none\\
\texttt{RETURN} & 24 & none & a return value \(s_0\) if the procedure has one & \textbf{not applicable}\\
\texttt{STOREGLOBAL} & 25 & 2 bytes (a short) with the index (id) of the global variable to store to & the value \(s_0\) to store into the global variable. & none\\
\texttt{STORELOCAL} & 26 & 2 bytes (a short) with the index (id) of the local variable to store to. Remember params! & the value \(s_0\) to store into the local variable. & none\\
\texttt{STOREOUTER} & 27 & 4 bytes & \textbf{Not implemented in this version. No support for block structure!} & \\
\texttt{SUB} \(\moredetails\) & 33 & none & first operand \(s_1\), second operand \(s_0\), both: int or float & \(s_1-s_0\)\\
\end{longtable}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
\end{document}