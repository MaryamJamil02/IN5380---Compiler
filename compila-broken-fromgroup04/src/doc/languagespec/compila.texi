\input texinfo    @c -*- texinfo -*-
@c %**start of header
@setfilename compila.info
@settitle 
@documentencoding UTF-8
@documentlanguage en
@c %**end of header

@dircategory 
@direntry
* .                     .
@end direntry

@finalout
@titlepage
@title Compila 23
@subtitle Language specification
@author INF5110, spring 2023
@author IFI
@end titlepage

@contents

@ifnottex
@node Top
@top 
@end ifnottex

@menu
* Introduction::
* Lexical aspects::
* Data types::
* Syntax::
* Parameter passing::
* Standard library::
* Static semantics / typing / evaluation.: Static semantics / typing / evaluation. 
* Procedures::
* Further conditions::

@detailmenu
--- The Detailed Node Listing ---

Introduction

* Notational conventions and syntax of this document::

Lexical aspects

* Identifiers and literals::
* Comments::

Data types

* Built in data types::
* Records::
* References::

Syntax

* Grammar::
* Precedence::
* Associativity::

Parameter passing

* Call-by-value::
* Small example for call-by-reference::

Static semantics / typing / evaluation.

* Binding of names::
* Typing of compound constructs::
* Types and implicit type conversion::
* Type inference::
* Short-circuit evaluation::

@end detailmenu
@end menu

@node Introduction
@chapter Introduction

This document specifies and describes the syntax and the static semantics
of the language @emph{Compila 23}.  The dynamic semantics, i.e., the description
of the language's behavior when being executed, should be fairly clear even
without explicit formal specification. 

@menu
* Notational conventions and syntax of this document::
@end menu

@node Notational conventions and syntax of this document
@section Notational conventions and syntax of this document

In the description of the grammar later, we use capital letters for
non-terminals. As @emph{meta-symbols} for the grammar, we use the following:


@example
   ->,  |,  (,  ), @{,  @},  [,  ], "  
@end example

Commas in the previous line are used as ``meta-meta symbols'' in the
enumeration of the meta-symbols.



When writing down the grammar in some variant of EBNF, @code{@{...@}} represents
iteration of zero or more times, @code{[...]} represents @emph{optional}
clauses. Everything else, written as contiguous sequences, are @emph{terminal
symbols}. Those with only @emph{small} letters are reserved @emph{keywords} of the
meta-language.

Note that terminal symbols of the Compila-language are written in
``string-quotes'' (i.e., with a @code{"} at the beginning and at the end) to
distinguish them from symbols from the meta-language. Some @emph{specific}
terminal symbols are written in capitals, and @emph{without} quotes.  Those are
@itemize
@item
@code{NAME},
@item
@code{INT_LITERAL},
@item
@code{FLOAT_LITERAL} and
@item
@code{STRING_LITERAL}.
@end itemize

See the following section about lexical aspects for what those terminal
symbols represent.

@node Lexical aspects
@chapter Lexical aspects

@menu
* Identifiers and literals::
* Comments::
@end menu

@node Identifiers and literals
@section Identifiers and literals

@itemize
@item
@code{NAME} must start with a letter, followed by a (possibly empty) sequence
of numeric characters, letters, and underscore characters; the
underscore is not allowed to occur at the end. Capital and small letters
are considered different.

@item
All @emph{keywords} of the languages are written in with lower-case
letters. Keyword @emph{cannot} be used for standard identifiers.

@item
@code{INT_LITERAL} contains one or more numeric characters.

@item
@code{FLOAT_LITERAL} contains one or more numeric characters, followed by a
decimal point sign, which is followed by one or more numeric characters.

@item
@code{STRING_LITERAL} consists of a string of characters, enclosed in
quotation marks (@code{"}).  The string is not allowed to contain line shift,
new-line, carriage return, or similar. The semantic @emph{value} of a
@code{STRING_LITERAL} is only the string itself, the quotation marks are not
part of the string value itself.
@end itemize

@node Comments
@section Comments

Compila supports @emph{single line} and @emph{multi-line} comments.


@enumerate
@item
Single-line comments start with @code{//} and the comment extends until the
end of that line (as in, for instance, Java, C++, and most modern
C-dialects).
@item
Multi-line comments start with @code{(*} and end with @code{*)}.
@end enumerate

The latter form cannot be nested. The first one is allowed to be ``nested''
(in the sense that a commented out line can contain another @code{//} or the
multi-line comment delimiters, which are then ignored).

@node Data types
@chapter Data types

@menu
* Built in data types::
* Records::
* References::
@end menu

@node Built in data types
@section Built in data types

The language has four built-in types and user-defined types:

@itemize
@item
@emph{Built-in types} 
@enumerate
@item
floating point numbers (@code{"float"}),
@item
integers (@code{"int"}),
@item
strings  (@code{"string"}), and
@item
booleans (@code{"bool"}).
@end enumerate

@item
@emph{User-defined} types: 
@enumerate
@item
Each (name of a) record represents a type.
@item
Reference types, representing references to elements 
of the specified types. The reference type constructor
can be nested.
@end enumerate
@end itemize

@node Records
@section Records

The language supports records. For people coming from Java/C++ etc.,
records can be seen as (very) simple form of classes, containing only
instance variables as members, but support neither @emph{methods} nor
@emph{inheritance} nor explicitly programmable @emph{constructors}. ``Instance
variables'' are more commonly called record fields or just @emph{fields} when
dealing with records. Records do support @emph{instantiation}, here via the
@code{new} keyword. Another aspect which resembles classes as in Java is that
variables of record type contains either a pointer to an element
(``object'') of that record type or the special pointer value
@code{null}.@footnote{Records are sometimes also called ``structs''.}

@node References
@section References

The language allows that variables can be declared to be of reference type
("pointers", if you will) by writing, e.g., 


@example
 var x: ref(int);
@end example


Variables,  like @code{x},  can be assigned values that are references, so, e.g.,
the following is allowed:

@example
var y: int;
y := 42;
x := ref(y);
@end example

Correspondingly, one can ``follow'' a reference @code{r} by using @code{deref(r)}, so
that, given the previous definitions, the following is legal:

@example
y := deref(x);
@end example

Expressions with @code{deref} can also be used as L-values, so that we can
assign values to the location that they are pointing to, e.g.:


@example
deref(x) := y;
@end example


See also later the swap procedure example later in the context of parameter
passing.

@node Syntax
@chapter Syntax

@menu
* Grammar::
* Precedence::
* Associativity::
@end menu

@node Grammar
@section Grammar

The following productions in EBNF describe the syntax of the language.  For
precedences and associativity of various constructs, see later.



@example
PROGRAM            -> "program" NAME "begin" [ DECL @{";" DECL@}]  "end"

DECL               -> VAR_DECL | PROC_DECL | REC_DECL

VAR_DECL           -> "var" NAME ":" TYPE [ ":=" EXP ] |  "var" NAME ":="  EXP 

PROC_DECL          -> "procedure" NAME 
                      "(" [ PARAMFIELD_DECL @{ "," PARAMFIELD_DECL @} ] ")"
                      [ ":" TYPE ]
                      "begin" [[DECL@{";" DECL@}] "in"] STMT_LIST "end"
REC_DECL           -> "struct" NAME "@{" [ PARAMFIELD_DECL 
                                          @{";" PARAMFIELD_DECL @}]  "@}"
PARAMFIELD_DECL     -> NAME ":" TYPE


STMT_LIST          -> [STMT @{";" STMT@}]    


EXP                -> EXP LOG_OP EXP
                    | "not" EXP
                    | EXP REL_OP EXP
                    | EXP ARITH_OP EXP
                    | LITERAL
                    | CALL_STMT
                    | "new" NAME
                    | VAR
                    | REF_VAR
                    | DEREF_VAR
                    | "(" EXP ")"

REF_VAR            -> "ref" "(" VAR ")"   ;; change that, a bit unbalanced
DEREF_VAR          -> "deref" "(" VAR ")" | "deref" "(" DEREF_VAR ")"

VAR                -> NAME | EXP "." NAME

LOG_OP             -> "&&" | "||" 

REL_OP             -> "<" | "<=" | ">" | ">=" | "=" | "<>"

ARITH_OP           -> "+" | "-" | "*" | "/" | "^"

LITERAL            -> FLOAT_LITERAL | INT_LITERAL 
                    | STRING_LITERAL | BOOL_LITERAL | "null"

BOOL_LITERAL       ->  "true" | "false" 

STMT               -> ASSIGN_STMT
                    | IF_STMT
                    | WHILE_STMT
                    | RETURN_STMT
                    | CALL_STMT

ASSIGN_STMT        -> VAR ":=" EXP | DEREF_VAR ":=" EXP

IF_STMT            -> "if" EXP "then"  STMT_LIST          
                       [ "else"   STMT_LIST  ] "fi"       
WHILE_STMT         -> "while" EXP "do"   STMT_LIST   "od" 

RETURN_STMT        -> "return" [ EXP ]

CALL_STMT          -> NAME "(" [ EXP @{ "," EXP @} ] ")"

TYPE               -> "float" | "int" | "string" | "bool" | NAME
                    | "ref" "(" TYPE ")"
@end example

@node Precedence
@section Precedence

The precedence of the following constructs is ordered as follows (from
lowest precedence to the highest):

@enumerate
@item
@code{||}
@item
@code{&&}
@item
@code{not}
@item
All relational symbols
@item
@code{+} and @code{-}
@item
@code{*} and @code{/}
@item
@code{^} (exponentiation)
@item
@code{.} (``dot'', to access fields of a record)
@end enumerate

@node Associativity
@section Associativity

@itemize
@item
The binary operations @code{||}, @code{&&}, @code{+}, @code{-}, @code{*}, and @code{.} are
@emph{left-associative}, but exponentiation @code{^} is right-associative.

@item
Relation symbols are non-associative. That means that for instance @code{a < b + c < d} is illegal.

@item
It's legal to write @code{not not not b} and it stands for @code{(not (not (not b)))}.
@end itemize

@node Parameter passing
@chapter Parameter passing

When describing the parameter passing mechanisms of the language, this
document distinguishes (as is commonly done) between

@itemize
@item
@emph{actual} parameters and
@item
@emph{formal} parameters.
@end itemize


The actual parameters are the expressions (which include among other things
variables) as part of a procedure @emph{call}. The formal parameters are the
variables mentioned as part of procedure @emph{definition}. The language
supports supports as only parameter passing mechanism call-by-value:

@menu
* Call-by-value::
* Small example for call-by-reference::
@end menu

@node Call-by-value
@section Call-by-value

The formal parameters are @emph{local} variables in the procedure
definition. When a procedure is being called, the @emph{values} of the local
parameters are @emph{copied} into the corresponding formal parameters.@footnote{The language supports reference types. Variables or expressions of
reference type are passed @emph{by value}. That leads to a behavior resembling
pretty much ``call-by-reference'', but the parameter passing mechanism
proper @emph{is} call-by-value (of reference data). One may speak of
call-by-value-reference.}

@node Small example for call-by-reference
@section Small example for call-by-reference

@example
program swapexample
  begin
    procedure swap (a :  ref(int), b : ref(int)) 
    begin
      var tmp : int
    in
      tmp      := deref(a);
      deref(a) := deref(b);
      deref(b) := tmp
    end;
    procedure main ( ) 
      begin
        var x : int;
        var y : int; 
        var xr : ref (int);
        var yr : ref (int)
       in
        x := 42; y := 84;
        xr := ref (x); yr := ref(y);
        swap (xr,yr)
      end
  end
@end example

@node Standard library
@chapter Standard library

The programming language comes with a standard library which offers a
number of IO-procedures. All reading, i.e., input, is done from standard
input (``stdin''). All writing, i.e., output, is to standard output
(``stdout'')

@multitable {aaaaaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem 
@tab 
@item @code{proc readint(): int}
@tab read one integer
@item @code{proc readfloat(): float}
@tab read one float
@item @code{proc readchar(): int}
@tab read one character and return its ASCII value. Return @code{-1} for @code{EOF}
@item @code{proc readstring(): string}
@tab read a string (until  first whitespace
@item @code{proc readline(): string}
@tab read one line
@item @code{proc printint(i:int)}
@tab write an integer
@item @code{proc printfloat(f:float)}
@tab write one floating point number
@item @code{proc printstr(s:string)}
@tab write one string
@item @code{proc printline(s:string)}
@tab write one string, followed by a ``newline''
@item 
@tab 
@end multitable

@node Static semantics / typing / evaluation
@chapter Static semantics / typing / evaluation.

@menu
* Binding of names::
* Typing of compound constructs::
* Types and implicit type conversion::
* Type inference::
* Short-circuit evaluation::
@end menu

@node Binding of names
@section Binding of names

The using occurrence of an identifier (without a preceding dot) is bound in
the common way to a @emph{declaration}. This association of the use of an
identifier to a declaration (``binding'') can be described informally as
follows: Look through the block or scope which encloses the use-occurrence
of the identifier (where the block refers to the procedure body or
program). The binding occurrence corresponding to the use occurrence is the
@emph{first} declaration found in this way.  If no binding occurrence is found
that way, the program is @emph{erroneous}. Formal parameters count as
declarations local to the procedure body.

Use occurrences of a name preceded  by a dot correspond to the clause @code{EXP
"." NAME} in the production for the non-terminal @code{VAR} in the grammar.
Those names are bound by looking at the type of @code{EXP} (which is required to
be a record-type) and look up the field with name @code{NAME} in that record. It's
an error, if @code{EXP} is not of record-type or else, there is not such field in
that record,

@node Typing of compound constructs
@section Typing of compound constructs

@itemize
@item
@strong{expressions:} expressions need to be checked for type correctness in the
obvious manner. The whole expression (if it type-checks) will thus
carry a type.
@item
@strong{assignments:} Both sides of an assignment must be of the same type.
Note: it is allowed to assign to the formal parameters of a
procedure. That applies to both call-by-value and call-by-reference
parameters. Of course, the effect of an assignment in these two
mechanisms is different.
@item
@strong{conditionals and while loop:} the condition (i.e., expression) in the
conditional construct must be of type @code{bool}. Same for the condition in
the while loop.
@item
@strong{field selection:}
@itemize
@item
the expression standing in front of a dot must be of record type.
@item
the name standing after a dot are the name of a field/attribute of the
record type of the expression in front of the dot. The type of the field
selection expression (if it type checks) is the type as declared for
the field of the record.
@end itemize
@end itemize

@node Types and implicit type conversion
@section Types and implicit type conversion

It is allowed to assign an expression of type @code{int} to a variable of type
@code{float}. The inverse situation is not allowed. There is no type cast
operator. If an @emph{arithmetic} expression has at least one operand of type
@code{float}, the operation is evaluated using floating point arithmetic and the
result is of type @code{float}. Exponentiation is @emph{always} considered done with
floating point arithmetic and the result is of type @code{float}.

@node Type inference
@section Type inference

The language requires a tiny bit of type inference (so small that one might
not even call type inference).  @emph{Variables} need to be declared, using the
keyword @code{var}. In particular, variables must have a type at the point when
they are declared. The declaration can be combined with a definition of an
initial value of introduced variable (using the syntax like @code{var x : int :=
42}). When provided with an initial expression, the type can be omitted
(using a syntax like @code{var x := 42}), in which case an appropriate type
needs to be inferred.

@node Short-circuit evaluation
@section Short-circuit evaluation

The logical operators @code{&&} and @code{||} use so-called @emph{short-circuit
evaluation}. That means that @emph{if} the value of the logical expression can
be determined after one has evaluated the @emph{first part, only}, the rest of
the expression is @emph{not} evaluated.

@node Procedures
@chapter Procedures

@itemize
@item
In a procedure, all declarations are required to occur @emph{before}
executable code (statements).  In a procedure, the @emph{same} declarations
are allowed as on the outermost, global scope, i.e., procedure-local
declarations of variables, procedures, and records are allowed.
@item
Procedures called within an expression @emph{must} have a defined return
type. That type must match with the way the call is @emph{used} in an
expression.
@item
Concerning the number and types of the parameters of a procedure: they
must coincide comparing the declaration/definition of the procedure and
the use of a procedure. That requirement applies also to the parameter
passing mechanism (i.e., whether the variable resp. actual parameter is
marked as ``by @code{ref}''.
@item
Return statements:
@itemize
@item
A @code{return}-statement is allowed only in procedure-definitions. Such a
statement marks that the procedure terminates (and returns). In
addition, the return statement gives an expression for the value to be
returned to the caller.
@item
If a procedure is declared without return type, the procedure does not
@emph{need} a return statement. In that case, the procedure returns
(without a return value) when the last statement in the procedure body
has been  executed.
@end itemize
@itemize
@item
If a procedure has declared a return type, its body is required to have
a return statement (with corresponding expression of the correct
type). That statement need to be the last statement in the procedure's
body.
@end itemize
@end itemize

@node Further conditions
@chapter Further conditions

@itemize
@item
Declarations must be @emph{unique} per block. Two declarations (within one
block) of a procedure, a record, or a variable with the same name are
considered as double declarations, which are @emph{forbidden}.
@item
The name of a formal parameter must not collide with names of local
declarations within the procedure. Besides, the names of all formal
parameters of one procedure must by distinct.
@item
All names being used must be declared.
@item
Each program must have a procedure named @code{main}. This procedure is the one
called upon start of the program.
@end itemize

@bye