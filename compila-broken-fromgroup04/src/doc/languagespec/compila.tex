% Created 2023-02-13 Mon 12:50
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{INF5110, spring 2023}
\date{\today}
\title{\\\medskip
\large Language specification}
\hypersetup{
 pdfauthor={INF5110, spring 2023},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={Compila 23 language specification},
 pdfcreator={Emacs 28.1 (Org mode 9.5.2)}, 
 pdflang={English}}
\begin{document}

\tableofcontents



\section{Introduction}
\label{sec:orgdf14c52}

This document specifies and describes the syntax and the static semantics
of the language \emph{Compila 23}.  The dynamic semantics, i.e., the description
of the language's behavior when being executed, should be fairly clear even
without explicit formal specification. 





\subsection{Notational conventions and syntax of this document}
\label{sec:org19282bb}

In the description of the grammar later, we use capital letters for
non-terminals. As \emph{meta-symbols} for the grammar, we use the following:


\begin{verbatim}
   ->,  |,  (,  ), {,  },  [,  ], "  
\end{verbatim}

Commas in the previous line are used as ``meta-meta symbols'' in the
enumeration of the meta-symbols.



When writing down the grammar in some variant of EBNF, \texttt{\{...\}} represents
iteration of zero or more times, \texttt{[...]} represents \emph{optional}
clauses. Everything else, written as contiguous sequences, are \emph{terminal
symbols}. Those with only \emph{small} letters are reserved \emph{keywords} of the
meta-language.

Note that terminal symbols of the Compila-language are written in
``string-quotes'' (i.e., with a \texttt{"} at the beginning and at the end) to
distinguish them from symbols from the meta-language. Some \emph{specific}
terminal symbols are written in capitals, and \emph{without} quotes.  Those are
\begin{itemize}
\item \texttt{NAME},
\item \texttt{INT\_LITERAL},
\item \texttt{FLOAT\_LITERAL} and
\item \texttt{STRING\_LITERAL}.
\end{itemize}

See the following section about lexical aspects for what those terminal
symbols represent.

\section{Lexical aspects}
\label{sec:orgbe222ac}
\subsection{Identifiers and literals}
\label{sec:org3ac8323}

\begin{itemize}
\item \texttt{NAME} must start with a letter, followed by a (possibly empty) sequence
of numeric characters, letters, and underscore characters; the
underscore is not allowed to occur at the end. Capital and small letters
are considered different.

\item All \emph{keywords} of the languages are written in with lower-case
letters. Keyword \emph{cannot} be used for standard identifiers.

\item \texttt{INT\_LITERAL} contains one or more numeric characters.

\item \texttt{FLOAT\_LITERAL} contains one or more numeric characters, followed by a
decimal point sign, which is followed by one or more numeric characters.

\item \texttt{STRING\_LITERAL} consists of a string of characters, enclosed in
quotation marks (\texttt{"}).  The string is not allowed to contain line shift,
new-line, carriage return, or similar. The semantic \emph{value} of a
\texttt{STRING\_LITERAL} is only the string itself, the quotation marks are not
part of the string value itself.
\end{itemize}


\subsection{Comments}
\label{sec:org2b172f6}

Compila supports \emph{single line} and \emph{multi-line} comments.


\begin{enumerate}
\item Single-line comments start with \texttt{//} and the comment extends until the
end of that line (as in, for instance, Java, C++, and most modern
C-dialects).
\item Multi-line comments start with \texttt{(*} and end with \texttt{*)}.
\end{enumerate}

The latter form cannot be nested. The first one is allowed to be ``nested''
(in the sense that a commented out line can contain another \texttt{//} or the
multi-line comment delimiters, which are then ignored).

\section{Data types}
\label{sec:org97b3710}

\subsection{Built in data types}
\label{sec:orgf5a6427}

The language has four built-in types and user-defined types:

\begin{itemize}
\item \emph{Built-in types} 
\begin{enumerate}
\item floating point numbers (\texttt{"float"}),
\item integers (\texttt{"int"}),
\item strings  (\texttt{"string"}), and
\item booleans (\texttt{"bool"}).
\end{enumerate}

\item \emph{User-defined} types: 
\begin{enumerate}
\item Each (name of a) record represents a type.
\item Reference types, representing references to elements 
of the specified types. The reference type constructor
can be nested.
\end{enumerate}
\end{itemize}


\subsection{Records}
\label{sec:org0f71bb8}

The language supports records. For people coming from Java/C++ etc.,
records can be seen as (very) simple form of classes, containing only
instance variables as members, but support neither \emph{methods} nor
\emph{inheritance} nor explicitly programmable \emph{constructors}. ``Instance
variables'' are more commonly called record fields or just \emph{fields} when
dealing with records. Records do support \emph{instantiation}, here via the
\texttt{new} keyword. Another aspect which resembles classes as in Java is that
variables of record type contains either a pointer to an element
(``object'') of that record type or the special pointer value
\texttt{null}.\footnote{Records are sometimes also called ``structs''.}

\subsection{References}
\label{sec:org3c7ca27}

The language allows that variables can be declared to be of reference type
("pointers", if you will) by writing, e.g., 


\lstset{language=compila,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
 var x: ref(int);
\end{lstlisting}


Variables,  like \texttt{x},  can be assigned values that are references, so, e.g.,
the following is allowed:

\lstset{language=compila,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
var y: int;
y := 42;
x := ref(y);
\end{lstlisting}

Correspondingly, one can ``follow'' a reference \texttt{r} by using \texttt{deref(r)}, so
that, given the previous definitions, the following is legal:

\lstset{language=compila,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
y := deref(x);
\end{lstlisting}

Expressions with \texttt{deref} can also be used as L-values, so that we can
assign values to the location that they are pointing to, e.g.:


\lstset{language=compila,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
deref(x) := y;
\end{lstlisting}


See also later the swap procedure example later in the context of parameter
passing.





\section{Syntax}
\label{sec:org0d2adb2}

\subsection{Grammar}
\label{sec:orgaccb58f}

The following productions in EBNF describe the syntax of the language.  For
precedences and associativity of various constructs, see later.



\lstset{language=compila,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
PROGRAM            -> "program" NAME "begin" [ DECL {";" DECL}]  "end"

DECL               -> VAR_DECL | PROC_DECL | REC_DECL

VAR_DECL           -> "var" NAME ":" TYPE [ ":=" EXP ] |  "var" NAME ":="  EXP 

PROC_DECL          -> "procedure" NAME 
                      "(" [ PARAMFIELD_DECL { "," PARAMFIELD_DECL } ] ")"
                      [ ":" TYPE ]
                      "begin" [[DECL{";" DECL}] "in"] STMT_LIST "end"
REC_DECL           -> "struct" NAME "{" [ PARAMFIELD_DECL 
                                          {";" PARAMFIELD_DECL }]  "}"
PARAMFIELD_DECL     -> NAME ":" TYPE


STMT_LIST          -> [STMT {";" STMT}]    


EXP                -> EXP LOG_OP EXP
                    | "not" EXP
                    | EXP REL_OP EXP
                    | EXP ARITH_OP EXP
                    | LITERAL
                    | CALL_STMT
                    | "new" NAME
                    | VAR
                    | REF_VAR
                    | DEREF_VAR
                    | "(" EXP ")"

REF_VAR            -> "ref" "(" VAR ")"   ;; change that, a bit unbalanced
DEREF_VAR          -> "deref" "(" VAR ")" | "deref" "(" DEREF_VAR ")"

VAR                -> NAME | EXP "." NAME

LOG_OP             -> "&&" | "||" 

REL_OP             -> "<" | "<=" | ">" | ">=" | "=" | "<>"

ARITH_OP           -> "+" | "-" | "*" | "/" | "^"

LITERAL            -> FLOAT_LITERAL | INT_LITERAL 
                    | STRING_LITERAL | BOOL_LITERAL | "null"

BOOL_LITERAL       ->  "true" | "false" 

STMT               -> ASSIGN_STMT
                    | IF_STMT
                    | WHILE_STMT
                    | RETURN_STMT
                    | CALL_STMT

ASSIGN_STMT        -> VAR ":=" EXP | DEREF_VAR ":=" EXP

IF_STMT            -> "if" EXP "then" { STMT_LIST }         <- NO
                       [ "else"  { STMT_LIST } ] "fi"       <- NO
WHILE_STMT         -> "while" EXP "do"  { STMT_LIST  } "od" <- NO

RETURN_STMT        -> "return" [ EXP ]

CALL_STMT          -> NAME "(" [ EXP { "," EXP } ] ")"

TYPE               -> "float" | "int" | "string" | "bool" | NAME
                    | "ref" "(" TYPE ")"
\end{lstlisting}


\subsection{Precedence}
\label{sec:orge2dfd3a}

The precedence of the following constructs is ordered as follows (from
lowest precedence to the highest):

\begin{enumerate}
\item \texttt{||}
\item \texttt{\&\&}
\item \texttt{not}
\item All relational symbols
\item \texttt{+} and \texttt{-}
\item \texttt{*} and \texttt{/}
\item \texttt{\textasciicircum{}} (exponentiation)
\item \texttt{.} (``dot'', to access fields of a record)
\end{enumerate}

\index{precedence}

\subsection{Associativity}
\label{sec:org61e8762}

\begin{itemize}
\item The binary operations \texttt{||}, \texttt{\&\&}, \texttt{+}, \texttt{-}, \texttt{*}, and \texttt{.} are
\emph{left-associative}, but exponentiation \texttt{\textasciicircum{}} is right-associative.

\item Relation symbols are non-associative. That means that for instance \texttt{a < b + c < d} is illegal.

\item It's legal to write \texttt{not not not b} and it stands for \texttt{(not (not (not b)))}.
\end{itemize}



\section{Parameter passing}
\label{sec:org2311157}


When describing the parameter passing mechanisms of the language, this
document distinguishes (as is commonly done) between

\begin{itemize}
\item \emph{actual} parameters and
\item \emph{formal} parameters.
\end{itemize}


The actual parameters are the expressions (which include among other things
variables) as part of a procedure \emph{call}. The formal parameters are the
variables mentioned as part of procedure \emph{definition}. The language
supports supports as only parameter passing mechanism call-by-value:

\subsection{Call-by-value}
\label{sec:org622cd66}

The formal parameters are \emph{local} variables in the procedure
definition. When a procedure is being called, the \emph{values} of the local
parameters are \emph{copied} into the corresponding formal parameters.\footnote{The language supports reference types. Variables or expressions of
reference type are passed \emph{by value}. That leads to a behavior resembling
pretty much ``call-by-reference'', but the parameter passing mechanism
proper \emph{is} call-by-value (of reference data). One may speak of
call-by-value-reference.}


\subsection{Small example for call-by-reference}
\label{sec:orge3e029f}


\lstset{language=compila,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
program swapexample
  begin
    procedure swap (a :  ref(int), b : ref(int)) 
    begin
      var tmp : int
    in
      tmp      := deref(a);
      deref(a) := deref(b);
      deref(b) := tmp
    end;
    procedure main ( ) 
      begin
        var x : int;
        var y : int; 
        var xr : ref (int);
        var yr : ref (int)
       in
        x := 42; y := 84;
        xr := ref (x); yr := ref(y);
        swap (xr,yr)
      end
  end
\end{lstlisting}


\section{Standard library}
\label{sec:orgad017b1}

The programming language comes with a standard library which offers a
number of IO-procedures. All reading, i.e., input, is done from standard
input (``stdin''). All writing, i.e., output, is to standard output
(``stdout'')

\begin{center}
\begin{tabular}{ll}
 & \\
\hline
\texttt{proc readint(): int} & read one integer\\
\texttt{proc readfloat(): float} & read one float\\
\texttt{proc readchar(): int} & read one character and return its ASCII value. Return \texttt{-1} for \texttt{EOF}\\
\texttt{proc readstring(): string} & read a string (until  first whitespace\\
\texttt{proc readline(): string} & read one line\\
\hline
\texttt{proc printint(i:int)} & write an integer\\
\texttt{proc printfloat(f:float)} & write one floating point number\\
\texttt{proc printstr(s:string)} & write one string\\
\texttt{proc printline(s:string)} & write one string, followed by a ``newline''\\
 & \\
\end{tabular}

\end{center}


\section{Static semantics / typing / evaluation.}
\label{sec:org816df5f}

\subsection{Binding of names}
\label{sec:org78c4750}
The using occurrence of an identifier (without a preceding dot) is bound in
the common way to a \emph{declaration}. This association of the use of an
identifier to a declaration (``binding'') can be described informally as
follows: Look through the block or scope which encloses the use-occurrence
of the identifier (where the block refers to the procedure body or
program). The binding occurrence corresponding to the use occurrence is the
\emph{first} declaration found in this way.  If no binding occurrence is found
that way, the program is \emph{erroneous}. Formal parameters count as
declarations local to the procedure body.

Use occurrences of a name preceded  by a dot correspond to the clause \texttt{EXP
"." NAME} in the production for the non-terminal \texttt{VAR} in the grammar.
Those names are bound by looking at the type of \texttt{EXP} (which is required to
be a record-type) and look up the field with name \texttt{NAME} in that record. It's
an error, if \texttt{EXP} is not of record-type or else, there is not such field in
that record,


\subsection{Typing of compound constructs}
\label{sec:org7f6f0f8}



\begin{itemize}
\item \textbf{expressions:} expressions need to be checked for type correctness in the
obvious manner. The whole expression (if it type-checks) will thus
carry a type.
\item \textbf{assignments:} Both sides of an assignment must be of the same type.
Note: it is allowed to assign to the formal parameters of a
procedure. That applies to both call-by-value and call-by-reference
parameters. Of course, the effect of an assignment in these two
mechanisms is different.
\item \textbf{conditionals and while loop:} the condition (i.e., expression) in the
conditional construct must be of type \texttt{bool}. Same for the condition in
the while loop.
\item \textbf{field selection:}
\begin{itemize}
\item the expression standing in front of a dot must be of record type.
\item the name standing after a dot are the name of a field/attribute of the
record type of the expression in front of the dot. The type of the field
selection expression (if it type checks) is the type as declared for
the field of the record.
\end{itemize}
\end{itemize}


\subsection{Types and implicit type conversion}
\label{sec:org9c8eeeb}

It is allowed to assign an expression of type \texttt{int} to a variable of type
\texttt{float}. The inverse situation is not allowed. There is no type cast
operator. If an \emph{arithmetic} expression has at least one operand of type
\texttt{float}, the operation is evaluated using floating point arithmetic and the
result is of type \texttt{float}. Exponentiation is \emph{always} considered done with
floating point arithmetic and the result is of type \texttt{float}.


\subsection{Type inference}
\label{sec:orgd141450}

The language requires a tiny bit of type inference (so small that one might
not even call type inference).  \emph{Variables} need to be declared, using the
keyword \texttt{var}. In particular, variables must have a type at the point when
they are declared. The declaration can be combined with a definition of an
initial value of introduced variable (using the syntax like \texttt{var x : int :=
42}). When provided with an initial expression, the type can be omitted
(using a syntax like \texttt{var x := 42}), in which case an appropriate type
needs to be inferred.

\subsection{Short-circuit evaluation}
\label{sec:org01bb3bc}

The logical operators \texttt{\&\&} and \texttt{||} use so-called \emph{short-circuit
evaluation}. That means that \emph{if} the value of the logical expression can
be determined after one has evaluated the \emph{first part, only}, the rest of
the expression is \emph{not} evaluated.

\section{Procedures}
\label{sec:org5157e7a}

\begin{itemize}
\item In a procedure, all declarations are required to occur \emph{before}
executable code (statements).  In a procedure, the \emph{same} declarations
are allowed as on the outermost, global scope, i.e., procedure-local
declarations of variables, procedures, and records are allowed.
\item Procedures called within an expression \emph{must} have a defined return
type. That type must match with the way the call is \emph{used} in an
expression.
\item Concerning the number and types of the parameters of a procedure: they
must coincide comparing the declaration/definition of the procedure and
the use of a procedure. That requirement applies also to the parameter
passing mechanism (i.e., whether the variable resp. actual parameter is
marked as ``by \texttt{ref}''.
\item Return statements:
\begin{itemize}
\item A \texttt{return}-statement is allowed only in procedure-definitions. Such a
statement marks that the procedure terminates (and returns). In
addition, the return statement gives an expression for the value to be
returned to the caller.
\item If a procedure is declared without return type, the procedure does not
\emph{need} a return statement. In that case, the procedure returns
(without a return value) when the last statement in the procedure body
has been  executed.
\end{itemize}
\begin{itemize}
\item If a procedure has declared a return type, its body is required to have
a return statement (with corresponding expression of the correct
type). That statement need to be the last statement in the procedure's
body.
\end{itemize}
\end{itemize}




\section{Further conditions}
\label{sec:orgf932ddf}

\begin{itemize}
\item Declarations must be \emph{unique} per block. Two declarations (within one
block) of a procedure, a record, or a variable with the same name are
considered as double declarations, which are \emph{forbidden}.
\item The name of a formal parameter must not collide with names of local
declarations within the procedure. Besides, the names of all formal
parameters of one procedure must by distinct.
\item All names being used must be declared.
\item Each program must have a procedure named \texttt{main}. This procedure is the one
called upon start of the program.
\end{itemize}
\end{document}

