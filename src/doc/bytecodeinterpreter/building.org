#+LINK: srcbytecode ../../../material/oblig2-patch/src/bytecode/%s
#+LINK: srcruntime ../../../material/oblig2-patch/src/runtime/%s

* Building a complete program

We have shown the basics of how a bytecode program (binary file) is built
using the bytecode library. In this section we will show some of the
details by covering each of the classes in the library. Details about all
the instructions will come in Section [[sec:rememberthis]].

The main parts for creating a new program are: create an object of the
class ~CodeFile~. Afterwards add the procedures, i.e., objects of class
~CodeProcedure~, structs, i.e., objects of class ~CodeStruct~, and so
on. Finally, when calling the ~getBytecode()~ procedure, the bytecode
library will generae the actual bytes from the object hat have been created
and from the ``properties'' given to those objects.

Note that there a /four/ steps to create a procedure (or a struct, or
global variable).

1. /add/ the definition to the ~CodeFile~ object via ~addProcedure~.
2. /create/ the ~CodeProcedure~ object via ~new CodeProcedure~.
3. /add/ ``properties'', such as the instructions, to the ~CodeProcedure~
   object.
4. /update/ the ~CodeProcedure~ object in the ~CodeFile~ via
   ~updateProcedure~


These four standard steps are illustrated in slightly more detail in the
following example.k

** A small example

The example code creates a program and first adds the name of a library
procedure to be used.  It then adds a procedure ~Main~, a global variable
~myGlobalVar~, a procedure ~test~ and a struct ~Complex~ (I). The main
procedure has the void return type, no parameters, no local variables and
the body consists of a single instruction, namely ~return~ (II). The global
variable is typed with the struct type ~Complex~ (III). The procedure
~test~ has 2 parameters (of type float and a reference type to
~Complex~). The procedure loads the first parameter onto the stack and then
calls the (library) procedure ~print_float~ to print its value (IV). The
struct ~Complex~ is created and the two fields, both of floating point
type, are added to it (V). The procedure ~print_float~ used in the program
is a library procedure. Nonetheless, it needs to be added, but without
instructions (VI). See Section [[sec:typicaltasks]] Finally, the mandatory main
method is set, before the bytecode can be extracted to a file (VII),



#+include: "codesnippets/simpleexample.javaoid" src java


*** Class ~CodeFile~


#+index: error: classes are not created
This is the class type cbyecode is created from and all elements must be
added to the corresponding object. It also proveds the servive of returning
indices to the given elements, as we will see later. Those indices are
needed when instruction classes are created. They reference the elements
within the program. Adding something to a ~CodeFile~ object is done in
/two/ stages; first, the element is added using something like the
~addProcedure~ procedure, supplying only the name. Then later, the
~updateProcedure~ must be called with a reference to the actual procedure
object. After a procedure has been added (but before it has been updated)
its index can be found and used, for example to crete a call to it, as we
will see.


An object of the ~CodeFile~ class is typically seen by all the nodes in the
abstract syntax tree, by for example passign around a reference to it. An
element in the syntax tree is typically responsible for adding itself to
the compiled result by using the procedures of the ~CodeFile~ or
~CodeProcedure~ classes.

A /global variable/& is added by using the procedure ~void
addVariable(String name)~. After a global variable has been added, its
index (~id~) in the program may be found using its name, calling the
procedure ~int globalVariableNumber(String name)~ The type of the variable
/must/ be supplied before the bytecode is generated. It is done by calling
~void uodateVariable(String name, CodeType type)~. All global variables
must have unique names.






