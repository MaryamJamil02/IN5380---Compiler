package parser;   
import java_cup.runtime.*;
import syntaxtree.*;
import java.util.*;

parser code {:

:};

/* Terminals */
/* Note, those might not be the terminals for this semester     */
/* Not all tokens are covered here, some may not be useful,     */
/* for instance, we won't have a "class" keyword,               */
/* but a "struct". Hence a corresponding token should better    */
/* be called STRUCT or similar, for clarity.                    */
terminal                        PROGRAM, STRUCT;
terminal                        PROCEDURE, BEGIN, IN, END;
terminal                        LPAR, RPAR;
terminal                        LBRACKET, RBRACKET;
terminal                        SEMI, COLON, COMMA, PERIOD, RETURN;
terminal String                 ID;
terminal String                 STRING_LITERAL;
terminal float                  FLOAT_LITERAL;
terminal int                    INT_LITERAL;
terminal                        VAR, ASSIGN;
terminal                        FLOAT, INT, STRING, BOOL, REF;
terminal                        NOT;
terminal                        NEW;
terminal                        DEREF;
terminal                        AND, OR;
terminal                        LESS, LESSEQUAL, GREATER, GREATEREQUAL, EQUAL;
terminal                        NOTEQUAL;
terminal                        PLUS, MINUS, MULTIPLY, SLASH, EXPONENT;
terminal                        NULL;
terminal                        TRUE, FALSE;
terminal                        IF, THEN, ELSE, FI;
terminal                        WHILE, DO, OD;


// Non terminals 
non terminal Program              program;
non terminal List<Decl>           decl_list;
non terminal List<Decl>           optional_decls;
non terminal Decl                 decl;
non terminal VarDecl              var_decl;
non terminal String               type; 
non terminal String               optional_type;
non terminal ProcDecl             proc_decl;
non terminal ParamfieldDecl       paramfield_decl;
non terminal List<ParamfieldDecl> paramfield_decl_list;
non terminal List<ParamfieldDecl> optional_paramfields;
non terminal RecDecl              rec_decl;
non terminal List<ParamfieldDecl> rec_decl_list;
non terminal List<Stmt>           stmt_list;
non terminal List<Stmt>           non_empty_stmt_list;
non terminal Exp                  exp;
non terminal RefVar               ref_var;
non terminal DerefVar             deref_var;
non terminal Var                  var;
non terminal String               log_op;
non terminal String               rel_op;
non terminal String               arith_op;
non terminal Literal              literal;
non terminal Boolean              bool_literal;
non terminal Stmt                 stmt;
non terminal AssignStmt           assign_stmt;
non terminal IfStmt               if_stmt;
non terminal WhileStmt            while_stmt;
non terminal ReturnStmt           return_stmt;
non terminal CallStmt             call_stmt;
non terminal List<Exp>            exp_list;


precedence left OR;
precedence left AND;
precedence right NOT;
precedence nonassoc LESS, LESSEQUAL, NOTEQUAL, EQUAL, GREATER, GREATEREQUAL;
precedence left PLUS, MINUS;
precedence left MULTIPLY, SLASH;
precedence right EXPONENT;
precedence left PERIOD;


/* The grammar */
program         ::= PROGRAM ID:name BEGIN decl_list:dl END
                      {: RESULT = new Program(name, dl); :}
                  | PROGRAM ID:name BEGIN END
                      {: RESULT = new Program(name, null); :};

decl_list       ::= decl_list:dl SEMI decl:d  
                      {: dl.add(d); RESULT = dl; :}
                   | decl:d
                      {: List<Decl> l = new LinkedList<Decl>();
                         l.add(d); RESULT = l; :};

decl            ::= var_decl:vd  {: RESULT = vd; :} 
                  | proc_decl:pd {: RESULT = pd; :} 
                  | rec_decl:rd  {: RESULT = rd; :};

var_decl        ::= VAR ID:name COLON type:t ASSIGN exp:e
                        {: RESULT = new VarDecl(name, t, e); :}
                  | VAR ID:name COLON type:t
                        {: RESULT = new VarDecl(name, t, null); :}
                  | VAR ID:name ASSIGN exp:e
                        {: RESULT = new VarDecl(name, null, e); :};

type            ::= FLOAT   {: RESULT = "FLOAT";  :}
                  | INT     {: RESULT = "INT";    :}
                  | STRING  {: RESULT = "STRING"; :}
                  | BOOL    {: RESULT = "BOOL";   :}
                  | ID:name {: RESULT =  name;    :}
                  | REF LPAR type:t RPAR {: RESULT = "REF(" + t + ")"; :};

proc_decl       ::= PROCEDURE ID:name 
                    LPAR optional_paramfields:pdl RPAR 
                    optional_type:t
                    BEGIN optional_decls:dl 
                    stmt_list:sl END
                    {: RESULT = new ProcDecl(name, pdl, t, dl, sl); :};

optional_paramfields ::= paramfield_decl_list:pdl {: RESULT = pdl; :}
                       | {: RESULT = null; :};

optional_type        ::= COLON type:t {: RESULT = t; :}
                       | {: RESULT = null; :};

optional_decls       ::= decl_list:dl IN {: RESULT = dl; :}
                       | IN {: RESULT = null; :}
                       | {: RESULT = null; :};

paramfield_decl_list ::= paramfield_decl_list:pdl COMMA paramfield_decl:pfd  
                            {: pdl.add(pfd); RESULT = pdl; :}
                        | paramfield_decl:pfd 
                            {: List<ParamfieldDecl> l = new LinkedList<ParamfieldDecl>();
                                l.add(pfd); RESULT = l; :};

paramfield_decl   ::= ID:name COLON type:t {: RESULT = new ParamfieldDecl(name, t); :};

rec_decl          ::= STRUCT ID:name LBRACKET rec_decl_list:rdl RBRACKET {: RESULT = new RecDecl(name, rdl); :} 
                    | STRUCT ID:name LBRACKET RBRACKET                   {: RESULT = new RecDecl(name, null); :};

rec_decl_list     ::= rec_decl_list:rdl SEMI paramfield_decl:pfd
                        {: rdl.add(pfd); RESULT = rdl; :}
                    | paramfield_decl:pfd 
                        {: List<ParamfieldDecl> l = new LinkedList<ParamfieldDecl>();
                            l.add(pfd); RESULT = l; :};

stmt_list ::= non_empty_stmt_list:sl {: RESULT = sl; :}
            | {: RESULT = new LinkedList<Stmt>(); :};

non_empty_stmt_list ::= non_empty_stmt_list:sl SEMI stmt:s
                          {: sl.add(s); RESULT = sl; :}
                      | stmt:s
                          {: List<Stmt> l = new LinkedList<Stmt>();
                             l.add(s);
                             RESULT = l; :};

exp               ::= NOT exp:e                   {: RESULT = new NotExp(e); :} 
                    | NEW ID:name                 {: RESULT = new NewExp(name); :} 
                    | LPAR exp:e RPAR             {: RESULT = e; :}

                    | exp:e1 log_op:o exp:e2      {: RESULT = new LogExp(e1, o, e2); :} 
                    | exp:e1 rel_op:o exp:e2      {: RESULT = new RelExp(e1, o, e2); :} 
                    | exp:e1 arith_op:o exp:e2    {: RESULT = new ArithExp(e1, o, e2); :} 
                    
                    | var:v                       {: RESULT = v; :} 
                    | ref_var:e                   {: RESULT = e; :} 
                    | deref_var:e                 {: RESULT = e; :} 
                    
                    | call_stmt:c                 {: RESULT = new CallExp(c); :} 
                    | literal:l                   {: RESULT = l; :};

ref_var           ::= REF LPAR var:v RPAR         {: RESULT = new RefVar(v);  :}
                    | REF LPAR ref_var:rv RPAR    {: RESULT = new RefVar(rv); :};

deref_var         ::= DEREF LPAR var:v RPAR        {: RESULT = new DerefVar(v);  :}
                    | DEREF LPAR deref_var:dv RPAR {: RESULT = new DerefVar(dv); :};

var               ::= ID:name                  {: RESULT = new Var(name);   :}
                    | exp:e PERIOD ID:name     {: RESULT = new Var(e,name); :};

log_op            ::= AND                      {: RESULT = "&&"; :}
                    | OR                       {: RESULT = "||"; :};

rel_op            ::= LESSEQUAL                {: RESULT = "<="; :}
                    | GREATEREQUAL             {: RESULT = ">="; :}
                    | NOTEQUAL                 {: RESULT = "<>"; :}
                    | LESS                     {: RESULT = "<";  :}
                    | GREATER                  {: RESULT = ">";  :}
                    | EQUAL                    {: RESULT = "=";  :};

arith_op          ::= PLUS                     {: RESULT = "+"; :}
                    | MINUS                    {: RESULT = "-"; :}
                    | MULTIPLY                 {: RESULT = "*"; :}
                    | SLASH                    {: RESULT = "/"; :}
                    | EXPONENT                 {: RESULT = "^"; :};

literal           ::= FLOAT_LITERAL:f          {: RESULT = new Literal(f); :}
                    | INT_LITERAL:i            {: RESULT = new Literal(i); :}
                    | STRING_LITERAL:s         {: RESULT = new Literal(s); :}
                    | bool_literal:b           {: RESULT = new Literal(b); :}
                    | NULL                     {: RESULT = new Literal( ); :};

bool_literal      ::= TRUE                     {: RESULT = true;  :}
                    | FALSE                    {: RESULT = false; :};

stmt              ::= assign_stmt:s            {: RESULT = s; :}
                    | if_stmt:s                {: RESULT = s; :}
                    | while_stmt:s             {: RESULT = s; :}
                    | return_stmt:s            {: RESULT = s; :}
                    | call_stmt:s              {: RESULT = s; :};

assign_stmt       ::= var:v ASSIGN exp:e       {: RESULT = new AssignStmt(v,e); :}
                    | deref_var:v ASSIGN exp:e {: RESULT = new AssignStmt(v,e); :};

if_stmt           ::= IF exp:e THEN stmt_list:sl1 ELSE stmt_list:sl2 FI {: RESULT = new IfStmt(e,sl1,sl2); :}
                    | IF exp:e THEN stmt_list:sl FI                     {: RESULT = new IfStmt(e,sl); :};

while_stmt        ::= WHILE exp:e DO stmt_list:sl OD  {: RESULT = new WhileStmt(e,sl); :};

return_stmt       ::= RETURN exp:e   {: RESULT = new ReturnStmt(e); :}
                    | RETURN         {: RESULT = new ReturnStmt();  :};

call_stmt         ::= ID:name LPAR exp_list:el RPAR 
                      {: RESULT = new CallStmt(name, el); :}
                    | ID:name LPAR RPAR 
                      {: RESULT = new CallStmt(name); :};

exp_list          ::= exp_list:el COMMA exp:e 
                        {: el.add(e); RESULT = el; :}
                    | exp:e
                        {: List<Exp> l = new LinkedList<Exp>(); 
                            l.add(e); RESULT = l; :};
                            